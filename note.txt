
									Training Nodejs
	
------------------------------------------------------------------------------------------------------------
	
- Cài đặt Nodejs:
	Truy cập vào trang web của nodejs: https://nodejs.org/en/ rồi tải về phiên bản Recommended For Most Users
		rồi cài đặt
	Sau khi kết thúc phần cài đặt, để kiểm tra xem phần cài đặt có thành công hay không thì có thể dùng CMD,
		Windows PowerShell hoặc sử dụng Git Bash để kiểm tra bằng câu lệnh: node -v
	Dùng câu lệnh npm -v để kiểm tra phiên bản(Node Package Manager), khi sử dụng nodejs thì cần cài thêm các 
		package vào --> npm giúp ta cài thêm các package vào. Khi cài đặt node thì nó sẽ tự động cài thêm npm
	Để kiểm tra đã cài đặt nodejs được chưa thì tự tạo 1 file js bất kỳ chẳng hạn server.js rồi dùng câu lệnh
		node server.js để chạy thử tập tin đó

- Hello NodeJS:
	Để thực thi chương trình trên Visual Studio Code thì sử dụng phím tắt là Ctrl + `
	https://nodejs.org --> DOCS --> Guides --> tạo 1 tập tin là app.js và thực thi chương trình bằng câu lệnh 
		node app.js --> Truy cập http://127.0.0.1:3000/ <--> http://localhost:3000
	const http = require('http'): Nodejs nó là tập hợp của rất nhiều module, có rất nhiều module được xây dựng
		sẵn, khi muốn sử dụng module nào thì sử dụng require + tên của module
	http.createServer(): Tạo ra Server
		req: Request là gì
		res: Response là gì
		res.end('Hello World\n') --> Trả về kết quả là 'Hello World\n'
	Ngắt kết nối: Ctrl + C
	
- Module:
	Tự viết 1 module và gọi vào để dùng.
	module.exports: Để dùng được module này thì cần phải exports ra
	Ở bên tập tin cần sử dụng phải kéo module đó vào bằng require
	listen(moduleOne.port): Các tham số ở đằng sau như hostname hay Error function thì nó sẽ sử dụng các giá trị
		mặc định
		
- Output HTML tag:
	Cách trả về 1 đoạn HTML hay 1 trang HTML
	require('./mmodule/config'): cùng thư mực với mmodule
	res.setHeader('Content-Type', 'text/text'): Xuất ra text
		res.end('<h1>Hello NodeJS</h1>');
	res.setHeader('Content-Type', 'text/html'): Xuất ra HTML
		res.end('<h1>Hello NodeJS</h1>');
		
- Sử dụng nodemon:
	Ở các phần trên cứ mỗi lần chỉnh sửa thì chúng ta phải ngắt server rồi sau đó chạy lại câu lệnh là node + tên
		tập tin(app.js)
	Để khi mà thay đổi tập tin mà không cần ngắt và chạy lại
	Keyword: nodemon npm
	Cách sử dụng nodemon: nodemon [your node app]
	
- Output HTML file: Đọc 1 tập tin HTML và xuất tập tin ra khi truy cập vào Site
	nodejs open html file
	fs.readFile(file[, options], callback)
	
- Routing:
	Vấn đề là làm sao để người dùng lấy được giá trị nhập trên URL ---> có thể dùng đến module mới đó là url
	Keyword liên quan: How to get the full url in Express?
	Giảm ngắn lại mã trong tập tin app.js --> Tách riêng code 1 số phần
	-->Viết gọn lại phần mã nguồn cho Routing 

			-----------------------------------------------------------------------------------------

										Express
-----> Là 1 Framework cho NodeJs

- Express generator:
	Site: https://expressjs.com/
	Express generator: Là 1 công cụ giúp ta tạo nhanh ra một ứng dụng trên Express
	Cách cài: npm install express-generator -g
	Cách tạo nhanh một ứng dụng: express --view=pug myapp
		--view: nó sẽ add vào 1 view engine, view engine này có thể là ejs|hbs|hjs|jade|pug|twig|vash
			như ở câu lệnh trên thì sẽ add vào view engine là pug
	Keyword: express template engine
	Trong phần này mình sẽ sử dụng template engine là ejs -> cài đặt: express --view=ejs project-nodejs
	Sau khi quá trình cài đặt kết thúc thì vào trong folder project-nodejs rồi chạy câu lệnh: npm install
	Khởi động server nodejs: npm start rồi sau đó vào http://localhost:3000/ để xem project được tạo ra

- Express structure:
	Tìm hiểu một số folder và tập tin khi mình tạo ra bằng Express generator
	Folder bin: có chứa tập tin là www. Kéo vào tập tin app và module http, và thực hiện khai báo port
		--> có thể thực hiên thay đổi được giá trị của port ở đây
	Folder node_modules: Khi sử dụng npm để cài đặt những thư viện, module để cài đặt về thì nó sẽ nằm 
		trong folder này(express, ejs)
		Khi mà thực hiện copy source code từ máy này sang máy khác thì chỉ cần Copy hết các tập tin và thư
			mục ngoại trừ thư mục node_modules này rồi sau đó dùng câu lệnh npm install để cài đặt --> nó 
			tạo ra folder node_modules và tự động download các package module về, chúng ta sử dụng các package
			module nào thì nó đều khai báo trong package.json
	Folder public: Là nơi chứa hình ảnh trong ứng dụng, js trong javascripts, css trong stylesheets
	Folder routes: Giúp ta khai báo các đường dẫn--> điều hướng đến các trang cần mở
	Folder views: Chứa các tập tin view
	Tập tin app.js: 
		Thực hiện kéo vào module express: var express = require('express')
		Tạo ra 1 app bằng cách sử dụng express: var app = express()
		app khai báo vị trí của folder views: app.set('views', path.join(__dirname, 'views')) , nếu mà mình 
			không muốn folder views có tên là views mà là tên khác thì chỉ cần cấu hình lại ở đây
		Cấu hình view engine: app.set('view engine', 'ejs')
		app.use(express.static(path.join(__dirname, 'public'))): Khai báo các tài nguyên về css, js, image thì
			vào bên trong folder public để lấy lên, nếu ko muốn để tên là public thì mình có thể đổi lại là được
		Khai báo sử dụng routes:
			app.use('/', indexRouter), trong đó: var indexRouter = require('./routes/index');
			app.use('/users', usersRouter), trong đó: var usersRouter = require('./routes/users');

- Nodemon: Ta muốn mỗi lần chỉnh sửa gì đó mà ko cần Stop lại server và khởi động lại server bằng npm start nữa
	mà nó sẽ tự động thực hiện --> cần phải sử dụng được nodemon trong Express generator.
	Keyword: Express generator auto restart
	Cài đặt nodemon: npm install -g nodemon
	Để sử dụng được nodemon: 
	-> package.json
		"scripts": {
			"start": "nodemon ./bin/www"
		},
	Start server bằng: npm start

- Sử dụng Router:
	Link: https://expressjs.com/en/guide/routing.html
	Route paths: Cũng có thể áp dụng biểu thức chính quy
		app.get('/ab(cd)?e', function (req, res) {
			res.send('ab(cd)?e')
		})
		--> đường dẫn sẽ match với các trường hợp là: /abe hoặc /abcde
	Route parameters: Tham số truyền trên URL
		Route path: /users/:userId/books/:bookId
		Request URL: http://localhost:3000/users/34/books/8989
		req.params: { "userId": "34", "bookId": "8989" }
		Xác định tham số truyền trên URL:
			app.get('/users/:userId/books/:bookId', function (req, res) {
				res.send(req.params)
			})
	Một số phương thức hay dùng khi sử dụng: res.redirect(), res.render(), res.send(), res.sendFile(), res.end()...

- Sử dụng View:
	Khi ta có 1 giao diện, làm thế nào để tích hợp vào project mình đang làm
	Hiểu cách thay đổi tập tin view cho từng Router khác nhau
	Để cho dễ dàng quản lý views thì trong folder views tạo thêm các folder để quản lý riêng cho các phần khác nhau
		chẳng hạn như: items, categories... --> Biết cách nhóm các view đối với các phần quản lý khác nhau
	Ở đây ta có itmes.js trong routes đóng vai trò giống như Controller
	---> Làm rõ hơn về cách sử dụng của Router và cách kéo view vào trong 1 Router nào đó.

- View - Include:
	Trong Folder views tạo thêm 1 folder nữa là elements
	Keyword: ejs include file
		cú pháp: <% include filename %>
	---> Biết cách kéo một tập tin vào bên trong một tập tin nào đó

- Kỹ thuật nhúng giao diện và module mở rộng: Tách giao diện thì mình sẽ tìm các phần giao diện chung để tách riêng ra
	--> Làm như vậy giúp ta thuận lợi khi maintain
	Tách giao diện phần navbar
	Cách Format code: chuyển về html --> chuột phải --> Format Document
	header: Tách riêng những phần nằm trong thẻ <head>
	script: Tách riêng những thẻ script được nhúng vào
	Để vào được các tập tin Css thì đường dẫn đúng là: http://localhost:6969/public/
	Khi tách các tập tin script và Header ra thì thứ tự bị thay đổi --> cần phải có base href để định lại đường dẫn
		đặt trong thẻ <head> ---> <base href="/">
	Keyword: html base href
	Folder pages: Để định nghĩa view của từng trang, quản lý các view chẳng hạn như qua lý các view dashboard, items
	Khi thay đổi vị trí của các tập tin view thì phần nội dung trong routes phần render() cũng phải thay đổi theo
	html format: Dùng để format code html
	Mỗi trang khác nhau thì có 1 Title khác nhau, nếu như mà thay đổi cấu trúc html của nó thì có bao nhiêu trang -> 
		phải thay đổi bấy nhiêu lần. Thay vì cứ mỗi trang mình phải lặp lại cấu trúc html của title thì mình sẽ tách nó
		ra thành 1 file riêng để khi mà khi thay đổi cấu trúc html dành cho title thì chỉ cần sửa ở 1 chỗ mà thôi
	In ra giá trị được truyền từ Router ra View: <%= pageTitle %>
	--> Tách ra thêm 1 phần quản lý title
	Keyword: ejs --> https://ejs.co/
	Nhúng giao diện cho phần add items
	Ở cứ mỗi trang thì mỗi view của nó tương đối là ít --> không cần Copy cấu trúc html của toàn bộ trang, nếu như mà 
		cấu trúc html của trang thay đổi thì mình phải đi tất cả các trang để thay đổi
		để tối ưu mã html thì ở mỗi trang, nó chỉ chứa mã html của chính nó --> mà ko cần chứa mã của toàn bộ trang
	Tùy thuộc vào việc mình sử dụng template engine là gì thì nó sẽ có package để tách được phần layouts ra
	Keyword: express-ejs-layouts --> https://www.npmjs.com/package/express-ejs-layouts
	Cài đặt: npm install express-ejs-layouts
	Khi cài đặt thành công thì kiểm tra trong file package.json và folder node_modules thì thấy nó đã có thêm 
		express-ejs-layouts
	Sau khi cài đặt xong thì import nó vào tập tin chạy chính app.js để sử dụng: 
		var expressLayouts = require('express-ejs-layouts');
	Thứ tự sắp xếp các module trong app.js:
		module của hệ thống 
		module cài thêm vào
		module tự viết
			var createError = require('http-errors');
			var express = require('express');
			var path = require('path');
			var cookieParser = require('cookie-parser');
			var logger = require('morgan');

			var expressLayouts = require('express-ejs-layouts');

			var indexRouter = require('./routes/index');
			var usersRouter = require('./routes/users');
	Khai báo sử dụng: app.use(expressLayouts);
	Set custom default layout: app.set('layout', 'layouts/layout');
	Tùy thuộc vào vị trí layout được đặt ở đâu thì tương ứng ta sẽ có đường dẫn, đường dẫn sẽ được tính từ Folder views
	In ra content: <%- body %>
	---> Trong app.js mình cài đặt express-ejs-layouts, khai báo sử dụng layout default là backend, trong backend thì 
		khai báo sử dụng cho phần content là <%- body %>

- Setup Router:
	Truy cập vào mỗi trang bằng cách gắn link
	Phần quản lý đường link thì mình có các đường link cho người quản trị và các đường link cho người sử dụng bình thường
		ở phần này mình sẽ xây dựng cho phần quản lý admin
	Theo cách viết ở trên thì trong file app.js mình cần import rất nhiều các Router vào, theo cách viết như vậy thì sẽ làm cho app.js
		có nhiều dòng. Ý tưởng ở đây là trong routes mình sẽ kéo các Router khác vào--> trong app.js mình chỉ cần kéo 
		file đại diện của từng phần(items, categories...) vào mà thôi, đồng thời giúp cho phần routes cũng rất dễ quản lý
		res.render('pages/home/index', { pageTitle: 'HomePage' }) --> Cách viết đúng
		res.render('/pages/home/index', { pageTitle: 'HomePage' }) --> Cách viết sai
	Đối với phần routes thì chia ra 2 phần là backend và frontend để dễ quản lý--> trong app.js chit cần import vào backend và
		frontend là được ---> đến khi thêm 1 view mới cho backend hoặc frontend thì chỉ cần viết trong routes/backend và
		routes/frontend rồi import và trong index của 2 thằng này là được

- Prefix Admin:
	Trong ứng dụng thì khả năng mở rộng, khả năng chuyển biến linh hoặt của nó phải cao
	Local variable: Là variable có thể sử dụng trong ứng dụng của mình
		app.locals.systemConfig = 'admin123'

- Error Page:
	Khi truy cập vào một đường dẫn không tồn tại --> phần error handler sẽ được gọi --> nó sẽ render về tập tin là error
		khi render ra trang error thì sẽ phát sinh lỗi bởi vì hiện tại app đang sử dụng layout là backend, layout này import
		vào title-page --> trong đây có sử đến pageTitle. Việc này dẫn đến khi render ra trang error thì nó chưa được truyền
		vào biến pageTitle --> lỗi bị phát sinh --> muốn không có lỗi thì khi render ra trang error thì chỉ cần truyền vào
		thêm biến pageTitle
	Có thể thay đổi cho trang Error như vị trí, nội dung hiển thị...
	Trong môi trường phát triển giành cho lập trình viên thì cho hiện thị các câu thông báo: 
		<h1><%= message %></h1>
		<h2><%= error.status %></h2>
		<pre><%= error.stack %></pre> 

- Review NodeJS:
	Tìm hiểu cơ bản về nodejs
	Cơ bản về cách dùng ExpressJs
	routes: Phân ra thành folder backend dành cho Router cho phần quản trị backend
			frontend dành cho phần quản trị frontend
	views: Tách ra cho từng trang riêng
	Giảm thiểu mã nguồn trùng lặp bằng cách sử dụng layouts backend
	Ngoài việc sử dụng template engine là ejs mình cũng đã sử dụng thêm 1 module nữa đó là express-ejs-layouts

- Mlab:
	Site: https://mlab.com/
	MongoDB Atlas: https://www.mongodb.com/cloud/atlas
	Tạo được ra DB ra trong MongoDB

- MongoDB Connect: Biết cách kết nối vơi mongodb thông qua dịch vụ của mlab
	Cách kết nối với cơ sở dữ liệu sử dụng MongoDB
	Thư viện(package) phổ biến giúp ta có thể làm việc được với MongoDB đó là Mongoose
	Site: https://mongoosejs.com/
		  https://mongoosejs.com/docs/guide.html  --> Bắt đầu từ Quick Start
	Cài đặt: npm install mongoose
	Keyword: mongodb atlas connect node
		--> https://docs.atlas.mongodb.com/connect-to-cluster/
	Trước tiên thì cần thực hiện 1 số yêu cầu:
		Tạo project: Training
		Thực hiện thêm Cluster mới
			Cluster Name: Cluster0
		Whitelist: Thực hiện add IP address  ở tab Security --> Add IP Address --> Allow Access from Anywhere, 
			khi add chỉ cần thực hiện các thông số mặc định 0.0.0.0/0
		MongoDB User: Để truy cập được vào cluster thì cần phải add thêm MongoDB User để có thể truy cập vào các 
			CSDL mong muốn trên Atlas cluster. Tài khoản MongoDB User là khác với tài khoản Atlas users. MongoDB user
			là dùng để truy cập vào CSDL MongoDB, còn Atlas users là để login vào ứng dụng Atlas
			user: vuquang
			pass: Vudinhquang2202
			Phân quyền là: Read and write to any database
		Kết nối với Cluster: Connect Your Application

- MoogoDB Quickstart

- Mongoose basic:
	Thực hiện hiển thị danh sách các item -> Cần đến câu lệnh Sellect
	Để dễ quản lý -> tạo thêm thư mục schemas, mỗi Collection sẽ có 1 tập tin schema riêng: items, categories...
	Keyword: mongoose get all items
	Mongoose thực hiện các phương thức và kết quả trả về được truyền vào lmaf tham số của hàm callback, đồng thời
		Mongoose cũng có phương thức .then() để thực hiện tiếp theo bước truy vấn.
		Tất cả các hàm callback đều có dạng callback(error, result)
			Trong trường hợp có lỗi xảy ra thì tham số error sẽ trả về 1 error parameter và result là null
			Ngược lại nếu truy vấn thành công thì error trả về null và result là kết quả của câu query

- Get items: Thực hiện truy vấn dữ liệu item và truyền ra view
	Ở đây thì dữ liệu được đổ ra view /admin/items --> Trong routes của items phải thực hiện lấy ra các items trong
		DB rồi truyền ra view
	Keyword: javascript print object
	<%= JSON.stringify(items) %> để hiện thị đối tượng trên view dưới dạng JSON

- Foreach:
	Khi đổ dữ liệu items ra view sử dụng Foreach --> hiển thị dữ liệu ra phần list item
	Để hiện thị các thông báo lỗi trong trang error để kiểm tra lỗi khi code:
		<h1><%= message %></h1>
		<h2><%= error.status %></h2>
		<pre><%= error.stack %></pre> 

- Status Helper:
	Khi xây dựng thêm các phần quản lý khác như categories, video... thì trên các view nó cũng có phần Status, phần này	
		sẽ được lặp lại -> Xây dựng phần Helpers hỗ trợ cung cấp sinh ra mã HTML giúp cho việc maintain cũng dễ dàng
	Include helper đã viết: <% include ../../helpers/status %>

- Show status filter: Lọc items theo status active, inactive, all + hiện thị có bao nhiêu phần tử ở trạng thái đó
	-> Các thuộc tính của mỗi nút filter đó là: 
		name: All/Active/Inactive, count: 4, link: '#', class(khi click vào phần tử nào thì phần tử đó được active)

- Count by status:
	Đối với trường status thì có thể nó có rất nhiều trạng thái: active, unactive, public, trash... -> thiết lập giá trị
		cho trường này là các giá trị text

- Helper Show Filter Status:
	Xây dựng helper cho phần hiển thị phần Filter trên view

- Helper Create Filter Status:
	Viết helper để tạo ra phần Status Filter -> làm giảm thiểu mã nguồn trong routes
	Sử dụng phương thức countDocuments() thay cho phương thức count()

- Status router:
	Dựa vào URL có thể lấy được các giả trị status: all, active, inactive, rồi từ đó hiện thị các giá trị theo Status
		đồng thời add class Css vào cho các nút Filter theo Status
	Cách ghi tổng quát cho status
		router.get('/:status', (req, res, next) => {
			res.write('test');
			res.end();
		});
	Cách lấy giá trị của status: req.params.status
	(/:status)?  -> trên URL thì giá trị này có thể xuất hiện hoặc không

- Active filter:
	Active cho các button Filter Status khi click vào các button đó để chuyển trang
	Hiện thị status khi hiện thị list các item

- List by status:
	Dựa vào trạng thái status ở trên URL mà mình sẽ đổ danh sách item ra ở phần list

- getParam:
	Khi mà không lấy được status từ URL, hoặc là giá trị của nó bằng rỗng thì gán giá trị mặc định cho nó là all
		nếu mà nó có tồn tại thì lấy giá trị của nó bình thường
	Keyword: javascript check object has property. javascript hasOwnProperty example
	--> Xử lý đế lấy giá trị: currentStatus
	Helper get param:
		let getParam = (params, property, defaultValue) => {
			if (params.hasOwnProperty(property) && params[property] !== undefined) {
				return params[property];
			}
			return defaultValue;
		}
		
- Filter Status - Error:
	Khi nhấn vào các filter status thì ta sẽ có các đường dẫn có dạng như:
		/status/active
		/status/inactive
		--> 'status' được bổ sung vào URL
	Error: Có lỗi bất đồng bộ xảy ra khi hiện thị giá trị count của mỗi status

-----------------------------------------------------------------------------------------
							   Xây dựng trang quản lý Item 
							   
Xây Dựng Chức Năng Tìm Kiếm
- Submit keyword: Thực hiện lấy giá trị keyword nhập vào khi nhấn nút Submit
	Khi nhắn nút tìm kiếm thì giá trị keyword được gắn lên trên URL, sau đó lấy giá trị keyword trên URL xuống để tìm
		kiếm
	Tùy thuộc vào mình đang ở trạng thái nào mà ta có đường link tương ứng khi tìm kiếm: /items/all?keyword=abc
		--> Truyền giá trị status hiện tại ra view để gắn vào đường link
	Khi nhấn vào nút Search để tìm theo keyword thì giá trị keyword nhập vào vẫn phải được hiển thị trên ô input
		-> Trong routes mình cần lấy được keyword trên URL rồi truyền nó ra view
	app.use(logger('dev')) ---> comment để ẩn đi một số dòng hiển thị trong console

- Search normarl: Đưa ra trị keyword lấy được ra view -> đưa vào hiển thị trong ô input, và lọc các item theo keyword đó
	hiển thị ở phần view

- Search RE: Tìm kiếm sử dụng đến Regular Expression
	keyword: mongoose Regular Expression, mongoose find regex
	objWhere = {name: { $regex: /socket/, $options: 'i' }}
		Tìm các giá trị có chứa giá trị 'socket' và không phân biệt chữ hoa, chữ thường
	objWhere = {name: new RegExp(keyword, 'i')};

- Clear & Reset: 
	Clear: Nhấn vào nút Clear để thực hiện xóa việc tìm kiếm -> quay về trạng thái ban đầu không thực tìm kiếm theo
	keyword
		Cách 1: Khi nhấn vào nút Clear thì thực hiện xóa giá trị trong ô input và thực hiện Submit Form
		Cách 2: Gắn link vào cho nút Clear, khi mà nhấn nút Clear thì quay về trang với status hiện tại
	Refresh: Vừa Reset phần Search -> không tìm kiếm theo status, vừa Reset theo status -> status được Reset về giá trị
		default là All
		-> Cách làm giống như là nút Clear, nhưng ở đây ta có status là All

- Update Filter status link:
	Khi thực hiện tìm kiếm theo keyword, người dùng nhấn vào nút chuyển trạng thái -> giá trị keyword vẫn phải được giữ
		nguyên trong ô input

---------------------------------------------------------------------------------------------

							Xây Dựng Chức Năng Phân Trang	

- Sort Helper:	Khi lấy dữ liệu ra thì mình cần có sự sắp xếp
	<%- %>: In ra mã HTML
	<%= %>: In ra giá trị của 1 biến 
	--> Khi return về mã HTML mà mình muốn in nó ra thì dùng <%- %>
	keyword: mongoose sort by date -> sort()
	Ở mỗi phần(item, user, group, category...) nếu chúng đều có phần phân trang -> Xây dựng Helper cho phần phân trang

- Fix Helper Status:
	`` ----> ${link}
	Sửa Helper cho phần status
	Sửa Helper cho phần filterStatus

- List by page:
	Cần xác định được có bao nhiêu phần tử trên một trang(limit)	-> Cấu hình
	Cần biết đang ở trang nào để biết là lấy từ phần tử nào(skip) --> Lấy trên URL
	keyword: javascript convert string to int
	skip:(currentPage -1)*totalItemsPerPage

- Total Items:
	Thống kê tổng cộng có bao nhiêu phần tử
	Tổng cộng có bao nhiêu trang
	Khi tìm kiếm cũng phải lọc theo Status và keyword

- Number:
	Thống kê tổng số trang: totalItems/totalItemsPerPage
	Tổng số phần tử trên một trang
	Ở trang hiện tại hiển thị phần tử nào đến phần tử nào: from -> to
		Nếu mà to > totalItems thì gán to = totalItems

- Start, Previous:
	Nút Start: Có thể có link hoặc không
		Nếu không phải trang đầu tiên -> có link
		Nếu là trang đầu tiên thì nó có link(disable)
	Nút Previous: 
		Khi đang ở trang 1 thì không cần có link
		Khi ở từ trang 2 trở đi thì cần có link

- Next, End: Xây dựng cũng tương tự như 2 nút Start và Previous
	Nếu trang hiện tại không phải trang cuối cùng thì gắn link cho Next và End
	Nếu mà đang ở trang đầu tiên thì không cần hiển thị 2 nút Start và Previous
	Nếu đang ở trang cuối cùng thì không cần hiển thị 2 trang Next và End
	--> Ban đầu gắn cho nó các giá trị là rỗng
	keyword: javascript declare multi variable --> Định nghĩa nhiều variable trên cùng 1 dòng

- Pages: Xây dựng phần giao diện để hiện thị những con số ở phần phân trang
	Cần có thêm phần active, chẳng hạn như nếu đang ỏ trang 3 thì ở 3 không cần gắn link cho nó và gắn thêm cho nó
		thêm 1 class(active)
	Tham khảo thêm cấu tạo của phần phân trang của Bootstrap 3

- Pagerange: Giới hạn số trang hiển thị ở phần hiển thị các con số
	-> Thiết lập thêm là muốn hiện thị lên bao nhiêu trang, thay vì có bao nhiêu trang thì hiện thị lên hết bấy 
		nhiêu trang
	VD: totalItems = 15, totalItemsPerPage = 2 -> totalPage = 8, pageRange = 5 -> midle = 5/2 = 3
		currentPage		xhtmlPages								 min = currentPage - midle + 1     max	= min + pageRange -1
		1				1 2 3 4 5									  1 - 3 + 1 = -1 <= 1 -> 1	   5				
		2				1 2 3 4 5									  2 - 3 + 1	= 0	 <= 1 -> 1	   5
		3				1 2 3 4 5									  3 - 3 + 1	= 1	 <= 1 -> 1     5

		4				2 3 4 5 6 -> currentPage nằm ở giữa		--	  4 - 3 + 1	= 2  			   6	 = 2 + 5 -1
		5				3 4 5 6 7 -> currentPage nằm ở giữa		--	  5 - 3 + 1	= 3				   7	 = 3 + 5 -1

		6				4 5 6 7 8									  6 - 3 + 1	= 4   -> 4		   8	   4 + 5 -1	= totalPage -> totalPage
		7				4 5 6 7 8									  7 - 3 + 1	= 5	  -> 4		   8	   5 + 5 -1 > totalPage -> totalPage
		8				4 5 6 7 8									  8 - 3 + 1	= 6   -> 4		   8	   6 + 5 -1 > totalPage -> totalPage
		--> Giá trị đầu và cuối sẽ thay đổi tùy thuộc vào giá trị của currentPage
			Do đó mình sẽ đặt ra 2 giá trị là min và max(của dãy số nằm trong pageRange)
			-> Cần xác định 2 giá trị min và max

- Fix pagination: Hoàn thiện cho phần phân trang
	Giải quyết trường hợp khi totalPages nhỏ hơn hoặc bằng giá trị thiết lập pageRanges -> min sẽ có giá trị là 1
		min = ((max - pageRanges + 1) <= 1) ? 1 : (max - pageRanges + 1);
	Khi nếu chỉ có 1 trang thôi thì không cần hiển thị cũng được --> xhtmlPagination = ''

- Link pagination:
	Giữ lại trạng thái lọc theo Status, cũng như giá trị tìm kiếm khi chuyển sang trang khác -> truyền giá trị Status
		ra helper pagination	
	Có cách sử lý khác đó là đưa các giá trị Status và keyword vào trong Session
	Phần quản lý pagination sẽ là phần dùng chung cho nhiều các phần quản lý khác: items, user, category -> để tổng quát
		hơn thì ở phần tạo link của pagination cần thêm 1 variable là type(items, user, category) -> dễ dàng tái sử dụng 
		mã nguồn	

----------------------------------------------------------------------------------------------------

									Xây dựng chức năng Change Status

- Link change status: Thay đổi trạng thái của 1 phần tử nào đó
	admin/items/change-status/12/active -> lấy được id và status của phần tử hiện tại
	res.send('test'): Truyền ra browser giá trị là 'test'

- Change status:
	Từ giá trị id và Status tiến hành cập nhật lại status cho item
	active <-> inactive
	keyword: Mongoose updateOne
	then()
	res.redirect() ---------res: Response
	Chỉnh sửa cho phần Change status bằng cách khi redirect về trang items thì ko fix cứng giá trị admin trong đường dẫn
		mà sử dụng giá trị trong config

- Delete item: Thực hiện chức năng là xóa 1 phần tử nào đó
	deleteOne()
	const linkIndex: Khai báo biến link cho index để có thể dùng chung cho các route

- Xây dựng chức năng Change Status cho nhiều phần tử:
	Chọn những phần tử mà mình muốn thay đổi trạng thái cho nó
	Chọn trạng thái muốn thay đổi
	Nhấn Apply
	Khi vừa vào trang thì nút Apply không Click được(vì chưa chọn hành động)
	Nếu nhấn nút Apply khi chưa chọn phần tử nào thì sẽ hiện lên câu thông báo yêu cầu chọn phần tử để thay đổi
	change_form_action: Chứa 3 tham số
		Tham số thứ nhất: Sellect box. Trong các option của Sellect Box thì lưu trực tiếp link mình muốn Submit đến
		Tham số thứ 2: Form -> chứa cả các input là checkbox, để khi mà Form Submit đi Form sẽ nhận được các giá trị 
			checkbox đó -> biết phần tử muốn thay đổi là phần tử nào
		Tham số thứ 3: Nút Apply
	test() trong javascript: Kiểm tra 1 giá trị nào đó có nằm trong 1 chuỗi hay không
	Form để method là post
	console.log(req.body): Kiểm tra các giá trị có trong req -> giúp ta lấy được các dữ liệu gửi từ Form
	keyword: mongoose update many, mongo update many
	https://docs.mongodb.com/manual/reference/operator/query/#query-selectors

- Delete multi item:
	Khi nhấn Apply để Delete thì hộp thoại để xác nhận được hiện lên
	Cần lấy được danh sách các id của item mà người dùng muốn xóa
	remove()

- Change ordering: Xây dựng chức năng Change Ordering của nhiều phần tử:
	Nhập giá trị mới cho ordering
	checkbox
	Chọn Change Ordering và nhấn nút Apply
	-> Có id và các giá trị ordering của các item muốn thay đổi
	Phần tử được check: $(".ordering").attr("name", "ordering")
	Phần tử không được check: $(".ordering").removeAttr("name")
	Có 2 trường hợp cập nhật đó là: Cập nhật 1 item và cập nhật nhiều item
	keyword: mongoose updateMany() -> giá trị update là cố định
	Cấu trúc từ phần Select, Button Apply và Button Add New khi mà qua các phần quản lý khác như quản lý User, quản
		lý group... sẽ tiếp tục lặp lại cấu trúc html đó -> tạo mới helper
	filterStatusHelper(): Thêm 1 tham số mới đó là collection rồi truyền vào giá trị là items
	actionHelper(): Để tạo mã html cho phần thay đổi status, ordering, delete

- Show messsage: Xây dựng chức năng hiển thị thông báo khi thực hiện xong 1 hành động nào đó
	keyword: nodejs express show notification
			express session
			setTimeout(): Thực hiện 1 hàm hay 1 biểu thức nào đó do mình viết sau 1 khoảng time nào đó
	site: https://www.npmjs.com/package/express-flash-notification
		https://www.npmjs.com/package/express-session
	Cài đặt: npm i express-flash-notification --save
	Copy:
		Trước: const app = express()
			const flash = require('express-flash-notification');
			const cookieParser = require('cookie-parser');
			const session = require('express-session');
		Sau: const app = express()
			app.use(cookieParser());
			app.use(session({...}}));
			app.use(flash(app));
	Express session:
		app.use(session({
			secret: 'qtgbjhyd',
			resave: false,
			saveUninitialized: true,
		}));
	Lỗi: Cannot find module 'express-session' 
		->Fix: npm install express-session
	In ra câu thông báo ở ngoài layout: <%- locals.flash %>
	Định nghĩa câu thông báo: req.flash('info', 'invalid username or password');
	Lỗi: Failed to lookup view "flash" in views directory "C:\xampp\htdocs\training-nodejs\project-nodejs\views"
	-> cần tạo ra 1 view flash.ejs trong thư mục views:
		<div class="alert flash">
			<button type="button" class="close">×</button>
			<i class="fa sign"></i><strong><%= type %></strong>
			<span><%= message %></span>
		</div>
	type: Ta có các loại thông báo như là thông báo thành công, lỗi: success, warning, danger...
	Error: Cannot set headers after they are sent to the client
		req.flash(String type, String message, Boolean renderInThisRequest) 
		->Trong trường hợp này thì change status, delete... không cần phải render -> renderInThisRequest có giá 
			trị là false
	Trường hợp mà cập nhật nhiều phần tử -> đưa ra cả số lượng phần tử được cập nhật
		keyword: mongoose update many get number of documents
	Hiện nay tập tin hiện thị câu thông báo đang mặc định tên là flash -> có thể thay đổi tên,
		cũng như là thay đổi vị trí đặt tập tin
		-> Khi sử dụng flash thì ngoài việc truyền vào app thì cần truyền thêm 1 đối tượng cấu hình các thông số

- Add item: Xây dựng chức năng Add phần tử
	form.ejs: Phần add và edit sẽ dùng chung 1 tập tin view
		add: form
		edit: form/id -> từ id lấy được các giá trị liên quan đến item đó rồi đổ ra lên trên view
	Kiểm tra URL nếu như mà có id thì nó là Form để Edit, còn nếu như mà không có id thì đó là trường hợp thêm mới
	Khi edit, ban đầu trang sẽ hiển thị đầy đủ thông tin của item cần edit -> cần lấy ra thông tin của phần tử
	Error: item.setPrototypeOf is not a function 
	keyword: req.body hasOwnProperty is not define
		Do đối tượng item đã được gán trực tiếp giá trị của req.body có dạng: 
			[Object: null prototype] { name: 'ABC 123', ordering: '123', status: 'active', id: '' }
	Fix: Để khắc phục lỗi này thì không nên gán từ req.body 
		có parse ra obj: req.body = JSON.parse(JSON.stringify(req.body));

- Xây dựng chức năng Validator:
	keyword: nodejs express validator
	Installation: npm install express-validator
	Kéo vào app.js để sử dụng: const flash = require('express-validator');
	errors = req.validationErrors(): Giá trị là false khi không có lỗi, nếu có lỗi thì nó là 1 array chứa phần tử ở 
		bên trong

- Validator: Thực hiện validate khi add item
	keyword: express validator check interger, express validator check not equal
	Tự xây dựng một validator riêng:
		Cách 1: router
			req.checkBody('status', 'Phải chọn status').custom(() => {
				if (req.body.status !== 'novalue') {
					return true;
				} else {
					return false;
				}
			});
		Cách 2: router và app
			app.use(validator(
				{
					customValidators:{
						isNotEqual: (val1, val2) =>{
							return val1 !== val2;
						}
					}
				}
			));
			req.checkBody('status', 'Phải chọn status').isNotEqual('novalue');

- Show Error: Thực hiện hiển thị các câu thông báo lỗi khi có lỗi xả ra
	Khi add dữ liệu mà có lỗi xảy ra thì vẫn ở lại trang Form và hiển thị lỗi lên trên trang đó
		-> Truyền giá trị errors lên trên view
	Xây dựng element riêng để hiện thị errors trên Form
	keyword: javascript uppercase first letter
	Object.assign(): được sử dụng để sao chép các giá trị của tất cả thuộc tính có thể liệt kê từ 
		một hoặc nhiều đối tượng nguồn đến một đối tượng đích. Nó sẽ  trả về đối tượng đích đó.

- Edit item: Edit thông tin của 1 phần tử nào đó
	Dựa vào giá trị id trong ô input rỗng được truyền đi từ form để phân biệt trường hợp Add và Edit

----------------------------------------------------------------------------------------------------

							Tối Ưu Và Hoàn Chỉnh Phần Quản Lý

- Notify: Sau khi thực hiện thành công 1 tác vụ nào đó -> hiện thị ra câu thông báo
	Khi quản lý các phần khác ko phải quản lý item thì các câu thông báo này cũng lặp đi lặp lại
	-> Tạo ra 1 tập tin để định nghĩa câu thông báo, điều này khiên việc muốn thay đổi nội dung câu 
		thông báo được thực hiện dễ dàng
	Hiện thị câu thông báo khi thay đổi status của nhiều item cùng 1 lúc:
	-> Sử dụng thư viện Utilities của Nodejs -> util.format()
	Hiện thị các câu thông báo khi Validate

- Folder view:
	Hiện tại thì item có 2 view đó là:
		form: pages/items/form
		list: pages/items/list
	-> Tổng quát hóa bằng cách đặt thêm biến folderView	 = 'pages/items/'

- Database config: Ở phần kết nối với mongodb thì nên tách ra thành 1 file cấu hình riêng để định nghĩa 
	các thông số database

- View: Khi tạo view cho các phần quản lý khác ngoài quản lý item thì để có thể sử dụng dễ dàng các view đã viết của item, 
	thì mình có thể thêm 1 số phần định nghĩa như sau trong list.ejs và form.ejs:
	const collection = 'items';
	const linkPrefix = systemConfig.prefixAdmin + '/' + collection + '/';

- Path: Có thể thay đổi tên folder/tập tin cũng như là vị trí của chúng(thay đổi cấu trúc thư mục) mà việc require chúng 
	được thực hiện dễ dàng
	keyword: nodejs define path
	-> Có nhiều giải pháp có thể sử dụng: https://gist.github.com/branneman/8048520
	Trong trường hợp này sử dụng Global
	Để cấu trúc tập tin của ta đỡ phức tạp và nhiều, dễ quản lý hơn. Ta tạo ra folder app để chứa mã nguồn mình sẽ viết
	Đặt phần cấu hình đường dẫn thành 1 tập tin riêng để dễ dàng quản lý

- Fix filter status: routes -> items.js
	Viết gọn mã nguồn đối với điều kiện lọc dữ liệu theo currentStatus và keyword

- Pagination: javascript đồng bộ và bất đồng bộ
	keyword: javascript promise, javascript async await
	Ở phần phân trang thì phải count số phần tử trước rồi mới thực hiện render ra view, nhưng vấn đề xảy ra là chưa thực
		hiện count xong thì phần render ở dưới nó đã thực Hiện
		Để khắc phục tình trạng này thì mình sử dụng async await
	-> Giải quyết được vấn đề lấy dữ liệu lên không kịp

- Fix filter status:
	Fix lỗi trong vấn đề hiển thị ở phần filterStatus đôi khi phần đếm bị sai, phần đếm số phần tử được đặt trong vòng lặp Foreach
		và đếm chưa thực hiện xong thì nó đã nhảy đến phần tử tiếp theo
	keyword: async await in Foreach
	Ở đây thì async await không dùng được với Foreach -> thay nó bằng for

----------------------------------------------------------------------------------------------------

- Publish:
	Tiến hành đưa sản phẩm lên hosting
	keyword: nodejs deploy
	App: nodejs-ver1
	-> Open app: https://nodejs-ver1.herokuapp.com/(link truy cập)
		trang Admin: https://nodejs-ver1.herokuapp.com/admin/items
	Sau khi cài đặt Heroku CLI vào thư mục dự án cần deploy và thực hiện các câu lệnh từ heroku login để deploy
	heroku logs: Lệnh để debug khi có lỗi khi deploy

Install the Heroku CLI
Download and install the Heroku CLI.

If you haven't already, log in to your Heroku account and follow the prompts to create a new SSH public key.

$ heroku login
Clone the repository
Use Git to clone project-nodejs-ver1's source code to your local machine.

$ heroku git:clone -a project-nodejs-ver1
$ cd project-nodejs-ver1
Deploy your changes
Make some changes to the code you just cloned and deploy them to Heroku using Git.

$ git add .
$ git commit -am "make it better"
$ git push heroku master

Sau khi push thành công quay lại trang ứng dụng của ta: https://project-nodejs-ver1.herokuapp.com/
Để xem log lỗi xảy ra: heroku logs --tail
-> nodemon: not found
Do đó cần sửa lại trong package.json:
	"start": "nodemon ./bin/www" -> "start": "node ./bin/www"
Rồi tiến hành commit và push lên heroku
Error: Failed to lookup view "pages/publish/index" in views directory "/app/views"
	-> Fix home.js trong routes
Tương tự fix lỗi khi click vào dashboard

----------------------------------------------------------------------------------------------------
									     Part 2
----------------------------------------------------------------------------------------------------
									Xây dựng trang quản lý Items nâng cao

- Add: Thêm mới thuộc tính created
	Tiếp tục thêm vào phần quản lý item phần tạo ra vào lúc nào và tạo ra bởi ai
	Để lưu được các nội dung này thì tạo thêm phần thuộc tính:
		created{
			user_id: ->created_by
			username -> tuy dư thừa dữ liệu nhưng khi trên phần quản lý item khi hiển thị thông tin người sửa
							sẽ không cần jion vào bảng user
			time:    ->created_at
		}
	Được chỉnh sửa lần cuối cùng bởi ai:
		modified{
			user_id: ->created_by
			username -> tuy dư thừa dữ liệu nhưng khi trên phần quản lý item khi hiển thị thông tin người sửa
							sẽ không cần jion vào bảng user
			time:    ->created_at
		}

- Edit - Status - Ordering:
	Lưu thông tin modified khi Edit status của 1 or nhiều phần tử, Edit ordering của 1 or nhiều phần tử hoặc khi
	thực hiện Edit phần tử

- Show date:
	Show thông tin modified và created lên trên view
	Thông tin item được tạo ra bởi người dùng nào, và time nào
	glyphicon -> Có thể sử dụng lệnh tắt của Bootstrap trên tập tin ejs
	-> EJS language support
	select('name status orderring created modified'): Giới hạn các thuộc tính lấy ra từ cơ sở dữ liệu
	moement: Thư viện của javascript để định dạng thời gian
	Cài đặt moment như 1 package dùng trong project: nodejs express moment
	keyword: Using Moment.js in Node.js
	Site: https://dzone.com/articles/using-momentjs-in-nodejs
		https://momentjs.com/
	Xây dựng helper để hiện thời gian theo format

- Sort: Thay đổi thứ tự sắp xếp trên view
	Tại 1 thời điểm thì chỉ sắp xếp theo 1 cột hoặc là name hoặc là ordering
	Có thể thực hiện bằng cách đưa lên URL: /colname=name&sorttype=desc
	...

- Link: 
	Tạo helper cho các phần tạo link cho phần sắp xếp
	Sắp xếp theo hướng nào thì giá trị hướng đó không phải do mình truyền vào mà là do sắp xếp hiện tại
		-> từ gia trị sắp xếp hiện tại suy ra được sắp xếp truyền vào link(hiện tại là asc thì truyền vào link
			là desc và ngược lại)

- Style: Thêm style để định dạng cho các cột khi tạo các phần sort
	sortHelper(collection, 'Name', 'name', sortField, sortType, 'width:20%')

- CKEditor: 
	Thêm thuộc tính mới về mô tả Item, nội dung này người dùng có thể định dạng chữ...
	-> Sử dụng ckeditor
	<script src="backend/js/ckeditor/ckeditor.js"></script>
	<textarea class="form-control" name="content" rows="2"  id="content_ckeditor" >

- Save:
	Tiến hành validate thông tin có hợp nệ hay không
	Tiến hành lưu thông tin(có thêm content)

----------------------------------------------------------------------------------------------------
								Xây dựng nhóm chức năng quản lý người dùng

-----Xây dựng chức năng quyền truy cập của nhóm người dùng:
- Group CRUD: Copy và kế thừa từ quản lý Item

- Fix filterStatusHelper: Fix phần thống kê status của Group

- Save:
	group_acp: Có giá trị bằng 1 thì có thể truy cập được vào vùng quản trị 0 thì không có quyền truy Cập
		vùng quản trị
	Khi hiện thị thông báo lỗi: group_acp -> Group Acp

- Show Group ACP: Trên trang Group Managment thì hiện thị lên group nào là nhóm quản trị, nhóm nào không
	phải nhóm quản trị

- Change Group ACP: Thực hiện chức năng thay đổi Group ACP

- Fix linkPrefix: 
	Viết gọn lại code bằng cách 
		Trên view đã có sẵn const linkPrefix = systemConfig.prefixAdmin + '/' + collection + '/' -> truyền
		vào làm tham số trong các helper

-----Xây dựng trang quản lý người dùng:
- User CRUD: Tạo phần CRUD cho phần user

- get groupsItems, selectboxGroupsItems: Trong trường hợp này thì mình cũng lưu dư thừa dữ liệu
	group{id, name} -> do đó ở phần hiển thị user thì mình có thể hiển thị lên luôn tên group mà không cần join
	Khi thêm user mới thì có SelectBox để chọn user đó thuộc về group nào
	selectboxGroupsItems: Xây dựng 1 helper để tạo ra SelectBox trên view
	groupsItems.unshift(): Bổ sung thêm 1 phần tử mới vào đầu mảng
	GroupsModel.find({},{_id:1, name:1}): Các trường cần lấy là id và name

- Group - Validate:
	Ctrl + K + 0: đóng lại
	Ctrl + K + J: mở hết
	Khi mà submit validate chưa thành công thì giá trị group đã được chọn phải được giữ lại

 - Save: Lưu thông tin của người dùng khi mà biết thông tin group của người dùng đó

 - Edit: Edit thông tin user

 - selectboxGroup: 
 	Hiển thị thêm thông tin Group của user
	Lọc danh sách user theo group:
		Có nhiều cách để thực hiện: Giống như phần filter theo status, search, submitform...
		Ở đây thì mình dùng Session
	Session: Khi chọn 1 phần tử nào đó -> gửi đến 1 url nào đó, thực hiện lưu Session
	Khi chọn 1 nhóm nào đó mà không có phần tử nào thì hiện thị câu thông báo cho người sử dụng


-----Tối ưu mã phần xây dựng Model 
- listItem:
	Tối ưu mã nguồn và tách nhỏ các phần xử lý giúp cho việc maintain dễ hơn
	Tìm cách tách phần Model riêng để cho routes chỉ đóng vai trò như là Controller
	Liên quan đến lấy dữ liệu -> đặt trong Model

- changeStatus: Xây dựng phương thức changeStatus để thay đổi status của 1 phần tử và nhiều phần
	tử cùng 1 lúc

- changeOrdering: 
	Khi vòng for chạy xong để thay đổi ordering của các phần tử xong thì nó return lại 1 promise
	keyword: promise resolve reject return 

- delete & get:
	Xóa 1 hoặc nhiều phần tử
	Lấy thông tin phần tử hiện lên trên Form khi thực hiện Edit

- save: Save thông tin phần tử khi add và save

- GroupsModel: Xây dựng Model groups để quản lý groups

- UsersModel: Xây dựng Model users để quản lý users

-----Cập nhật đồng bộ thông tin nhóm người dùng
- Save group name:
	Tên group ở đây ít bị thay đổi -> có thể sử dụng kỹ thuật dư thừa dữ liệu để lưu tên group trong 
		user
	Trong bảng users thì user có lưu cả thông tin nhóm người dùng, vì vậy để khi mà ta thay đổi
		thông tin nhóm người dùng -> trong user cũng phải cập nhật lại.

- Optimize add edit:
	Tối ưu hóa mã nguồn cho phần add và edit

----------------------------------------------------------------------------------------------------
							Xây dựng nhóm chức năng quản lý bài viết

-----Xây dựng chức năng quản lý category
- Category:
	Trong Category thì có nhiều bài viết, như vạy thì ta thấy mối quan hệ của category với item nó giống với
		mối quan hệ của group với item
	Category ở đây có thêm 1 trường nữa đó là slug
	Slug:
		Khi nhập vào ô name của category thì ở ô slug sẽ tự động được nhập vào dạng slug được chuyển từ name
		validate cho slug
		Mặc dù giá trị được tự động chuyển đổi từ giá trị name nhưng người dùng vẫn có thể nhập giá trị khác
			vào slug, lúc này khi submit thì giá trị ở trong ô slug sẽ được chuẩn hóa lại theo đúng cấu trúc
			của trường slug -> ở Model khi lưu thì sẽ tiến hành chuyển hóa lại

-----Sử dụng multer trong việc upload hình ảnh
- Multer - Basic:
	Ở phần quản lý người dùng thì người dùng có ảnh đại diện và ảnh avata của họ -> khi mà tiến hành thêm mới
		cần có 1 field để chọn hình đại diện của 1 người dùng nào đó.
		Edit user cũng có thể cập nhật lại ảnh đại diện của 1 người dùng nào đó
	Keyword: nodejs multer
	Site:https://www.npmjs.com/package/multer
	Cài đặt: $ npm install --save multer
	Thiết lập nơi chứa tập tin mà ta upload lên
	Demo: http://localhost:6969/admin/users/upload
	NOTE: Multer will not process any form which is not multipart (multipart/form-data).
- Multer - fileName fileSize:
	Sử dụng hàm sinh ra chuỗi ngẫu nhiên để đặt tên cho file được upload lên
		Keyword: nodejs random string
		Cài đặt: npm install randomstring
		Lấy phần mở rộng của tập tin: const path = require('path')
	Giới hạn dung lượng của tập tin
		Keyword: multer filesize

- Multer - fileFilter:
	Giới hạn phần mở rộng của 1 tập tin nào đó
	Keyword: multer fileFilter
	-> Tìm hiểu cách validate phần mở rộng của tập tin khi upload

- Multer - uploadHelper: Viết helper để thực hiện việc upload

- Multer - customError:
	Bắt câu thông báo lỗi khi thực hiện việc upload
	Định nghĩa khi validate extension file
		if (err) {
			if (err.code === 'LIMIT_FILE_SIZE') {
				errors.push({ 'param': 'avatar', 'msg': 'Kích thước file upload quá lớn' });
			}

			if (err.extname) {
				errors.push({ 'param': 'avatar', 'msg': err.extname });
			}
		}
	Khi có lỗi xảy ra thì đẩy thêm phần tử vào errors rồi truyền ra view

-----Xây dựng chức năng upload avatar
- Upload Avatar: Thực hiện validate avatar khi thêm user mới
- Save avatar:
	Upload ảnh người dùng chọn làm avatar
	Lưu tên ảnh vào trong bảng users
- Show avatar:
	Hiển thị ra những hình ảnh avatar của user lên view list user
	Không cần sắp xếp theo trường này
	Trường hợp user chưa có avatar thì hiển thị 1 hình ảnh avatar mặc định
- Delete Avatar - Single:
	Khi thực hiện xóa user thì ngoài việc xóa thông tin user trong database thì cần phải thực hiện xóa hình ảnh
		avatar của user
	Keyword: nodejs fs
	Nếu ảnh có tên là no-avatar thì sẽ ko khóa, ảnh có tên khác thì thực hiện xóa
	Việc thực hiện xóa avatar cũng để cho deleteItem trong Model nó thực hiện

- Delete Avatar - Multi:
	Khi xóa nhiều user thì cũng xóa hết các hình của các user đó

- FileHelper:
	Xây dựng helper phần thực hiện xóa file avatar
- Fix upload image:
	Khi thêm mới 1 user mà chỉ chọn 1 tập tin làm avatar trong khi đó các trường khác ko làm gì -> validate không
		thành công nhưng tập tin vẫn được upload
	Các cách sử lý:
		- Vẫn chấp nhận cho nó upload lên, sau đó tiến hành xóa file đó đi
- Custom error:
	Validate yêu cầu chọn 1 tập tin làm avatar khi thêm 1 người dùng
	Khi thực hiện chức năng Edit thì thành viên đó đã có ảnh trước rồi -> không bắt buộc người dùng phải thêm tấm 
		hình mới
- Optimize validate:
	Đưa các phần về lỗi validate vào trong cùng 1 tập tin validate của user làm gọn code trong routes

- Edit - show avatar:
	Khi edit thì phải hiển thị lên tấm hình avatar hiện tại của user đó
- Edit - submit:
	Khi thực hiện Edit user -> hình ảnh avatar của user đó cũng đã được hiện thị lên
	-> Giải quyết 2 vấn đề:
		Không edit hình ảnh avatar mà chỉ edit thông tin của các trường khác -> phải giữ lại hình ảnh cũng
			phải giữ lại
		Vừa edit thông tin ở phía ngoài và vừa edit hình ảnh avatar
	Như vậy thì khi Edit cần giải quyết 2 trường hợp đó là: Họ chỉ edit những thông tin cơ bản or edit cả hình avatar
	Tại tập tin Form khi Edit thì hiển thị tấm hình cũ
	Tên của tấm hình cũ -> đặt trong ô input ẩn
	Khi edit mà edit hình mới thì cần phải xóa tấm hình cũ đi
- Edit - finish:
	Keyword: req.body empty multer
	Trường hợp thêm mới và edit mà nhập vào hình ko hợp lệ thì ko validate được và ko giữ được giá trị của các trường 
		khác đứng sau avatar trên view form
	Như vậy thì khi mà validate avatar bị lỗi thì những phần tử ở phía dưới avatar trên Form nó sẽ bị vô hiệu hóa và ko
		được validate
	Cách khắc phục đơn giản nhất đó là đặt vị trí của avatar ở dưới cuối Form để cho tất cả các phần ở phía trên nó được
		validate rồi sau đó validate avatar
	Cách khác đó là dùng javascript để sắp xếp lại các fields trước khi thực hiện vấn đề gửi
	Khi Edit chọn avatar không hợp lệ -> hình cũ vẫn phải được giữ lại
	Form: name="form-upload"
		$("form[name=form-upload]").submit(function (event) {
			let avatar = $(this).find("input[name=avatar]");
			$(this).find("input[name=avatar]").remove();
			$(this).append(avatar).css({ 'display': 'none' });
		});
    errors = req.validationErrors();
    if(!errors) errors = [];
	let errors = req.validationErrors() !== false ? re.validationErrors() : [];
-----Hoàn chỉnh chức năng validate
- Validate:
	Đồng bộ hóa mã nguồn validate của item và kiểm tra errors khi check validate trên routes giống với user

-----Xây dựng chức năng quản lý bài viết
- Article: Xây dựng phần quản lý bài viết
	Mối quan hệ của article và category giống với mối quan hệ của user và group
	user có avatar thì article có ảnh làm hình đại diện của 1 bài viết nào đó

----------------------------------------------------------------------------------------------------
							Xây dựng nhóm chức năng kết hợp Frontend và Backend

-----Nhúng giao diện cho vùng Frontend
- Folder view:	Các folder chứa tập tin views, chia ra để quản lý
	module admin
	module blog
	-> Thay đổi nơi chứa folder views theo module:
	Thay đôi và sắp xếp lại vị trí của các tập tin, thư mục nên các đường dẫn cũng bị thay đổi
	app: Thay đổi đường dẫn đến flash, layout và render của layout
	routes: Đường dẫn đến folder view(folderView)

- Intro Template: Template cho phần frontend

- Folder template:
	Trong folder public là những tập tin về tài nguyên css. js...
	Để dễ hệ thống thì chia làm các folder để quản lý
	Lúc này đường dẫn sẽ bị thay đổi, do đó ở những phần kéo vào css và js... cần phải thay đổi lại
	elements/header: Nơi kéo vào css
	elements/scripts: Nơi kéo vào js

- Nhúng Template:
	Nhúng giao diện cho phần frontend
	Phân chia tập tin, tách tập tin cho blog: elements, pages, frontend.ejs(template)
		elements: footer. head, header, script, sidebar, top_post
		pages: category, home, post
		layout: frontend.ejs
	Hiện tại thì khi truy cập vào http://localhost:6969/admin/ thì sẽ truy cập được vào template backend
		layout đang được thiết lập là backend trong admin
	Khi truy cập vào đường dẫn http://localhost:6969/ thì sẽ truy cập đường vào template frontend
		layout phải được thiết lập là frontend
	-> Trong phần khai báo routes thì có thể chỉ định layout giành cho router đó là layout nào
	Keyword: How to specify layout in res.render function

- Top post:
	Khai báo router cho category và post
	category: Lấy giao diện hiển thị các bài viết trong 1 category
	post: Xem thông tin chi tiết 1 bài viết 
		phần những bài viết liên quan lấy 1 số bài viết cùng category với bài viết đó
	Cụm bài viết top_post chỉ hiển thị trên trang index(home)

-----Xây dựng vùng hiển thị bài viết nổi bật
- Analyst:
	Thêm 1 trường mới đó là special vào cho bảng articles, giá trị của special là true thì cho nó hiển thị ở
		vùng top post
	Việc thay đổi giá trị của trường special thì thực hiện cũng giống như status
	Các việc cần phải thực hiện đó là:
		backend: thay đổi special
		frontend: lấy các bài viết có special = true
- Backend: Chọn 1 bài viết nào đó có nằm ở vị trí top hay không, special được thêm vào và làm tương tự như status

- Frontend: Lấy những bài viết để nó show ra hiển thị ở vị trí top
	Các bài viết này phải có special là active, đồng thời giá trị của status cũng phải là active
	Giới hạn các phần tử lấy ra là 3
	Định dạng thời gian -> config giá trị
	Tình huống mở rộng: Không phải lúc nào cũng có 3 bài viết có giá trị special là true
		Nếu chỉ có 2 -> có 1 template để hiện thị 2 bài viết
		Nếu chỉ có 1 -> có 1 template để hiện thị 1 bài viết
		Nếu không có -> có 1 template để hiện thị 0 bài viết
		Cách 2: Nếu có 3 thì mới hiển thị, còn ko thì ko hiển thị

-----Xây dựng vùng hiển thị bài viết mới nhất:
- Fix special: Xử dụng async await để sửa lại routes phần lấy dữ liệu bài viết hiển thị trên phần top post
- Get data: Thực hiện lấy data new post và viết lại clear code phần top post và new post
- Show data: Hiển thị những bài viết mới nhất
	keyword: javascript substring
	Vì nội dung của content quá dài nên thông thường thì người ta dùng phần miêu ta ngắn của bài viết để hiển thị
		trên trang index 
	Đối với phần cắt chuỗi bằng substring thì cần xử lý tinh giả dụ: vũ đình quang -> vũ đình...
		chưa được xử lý tinh thì hay có dạng đó là: vũ đình qua...

-----Xây dựng trang hiển thị bài viết của category
- Category Menu: Lấy ra các category và đổ vào phần menu category nằm ở header của trang home
- Link: Gắn link cho các category nằm trong header
	Khi truy cập vào 1 category nào đó thì sẽ hiển thị ra các bài viết nằm trong category đó
- Get data: 
	Lấy ra danh sách các bài viết dựa vào id của category
- Show data: Hiển thị thông tin các bài viết của từng category
	Ở đây xử lý với trường hợp là có dữ liệu
- Helper: 
	Xây dựng helper cho phần định dạng thời gian, phần hiển thị miêu tả ngắn bài viết
	Phần hiển thị miêu tả ngắn thì cần xóa đi các thẻ html mà chỉ giữ lại phần nội dung
	Keyword: js remove html tag -> text.replace(/<[^>]+>/g, '');
	Thông thường thì nếu tạo thêm ra 1 trường cho phần miêu tả ngắn summary thì thường nó là 1 text area(ko có editer) 
	nên khi nhập nó ko có định dạng gì cả, lúc đó thì sẽ ko cần sử dụng phần xử lý chuỗi là loại bỏ đi các thẻ html.

-----Xây dựng các thành phần của trang
- Page: Thực hiện hoàn thiện thành phần menu và xử lý khi người dùng truy cập vào 1 trang ko tồn tại
	Hoàn thiện phần menu: thêm trang contact và about
		Điều chỉnh link và khai báo router(contact và about)
	Khi người dùng gõ vào 1 đường dẫn không tồn tại thì mở ra trang không tồn tại
		env: 'production' // Truyền production dev
		Trang này không cho hiển thị top_post
		layout hiển thị là layout frontend
		Hiển thị itemsCategory(Ở Menu)
	Hướng phát triển mở rộng:
		contact: có thể thêm Form liên hệ của người dùng
		about: có thể nhúng thêm địa chỉ của website, bản đồ, giới thiệu website...
		Khi người dùng vào 1 trang ko tồn tại thì mở ra trang 404
			Khi có lỗi xảy ra mình định nghĩa 2 môi trường đó là dev và production -> thiết lập trong config
- Setting:
	Trên trang của ta có 1 số phần như là logo, twister, địa chỉ, số điện thoại, email, social network, ảnh quảng cáo,
		footer, link kết nối đến facebook, twister.
	Những phần này ko nên fix cứng trong code

	Cách thiết kế:
	1-Info: Tạo  form cho người dùng nhập vào
		Logo  -> input type= file cho người dùng up 1 tập tin lên(logo)
		Email -> input type= text cho người dùng nhập vào địa chỉ email web của họ
				vuquangk53@gmail.com			true(mail liên hệ chính)
				vuquang@gmail.com				false
		Phone -> input type= text
		Copyright
	2-Social network: Khi lấy để hiện thị lên màn hình, nếu cái nào có giá trị thì đổ lên view, nếu ko có giá trị thì 
		không cần đổ
		facebook -> input type= text
		youtobe  -> input type= text
	3-Script và Custom HTML
		Ví dụ: Khi người dùng muốn thay đổi giá style cho bài viết(màu)
		Header:				<style> h1 {color: red} </style>
		Footer: Nội dung style người dùng nhập vào nằm ở cuối trang, trước thẻ đóng </body>
		Google Analyst
		Google adsense
	4-Fanpage
	Colection setting:
		id			key				value					description				params
		1			logo			hdhdhdh.jpg				Logo của trang web
		2			email			vuquangk53@gmail.com	Email liên hệ			vuquangk53@gmail.com, vuquang@gmail.com	
		3			phone 			0908903
		4			custom_html		<style> h1 {color: red} </style>

	Sau khi lưu các giá trên trị vào db xong rồi, nếu muốn nhanh nữa thì tiến hành lưu vào trong cookie của người dùng
	(Local storage) -> Đọc hết trong bảng setting rồi lưu vào trong cookie. Trong những lần sau khi mà người dùng truy
		cập thì thay vì đọc từ db thì mình sẽ đọc từ Local storage
		Có thể thiết lập thời gian của local storage
		Mỗi lần vào -> kiểm tra trong local storage xem nó đã tồn tại quá time chưa, nếu quá rồi thì đọc trong bảng setting
			ra, chưa thì vẫn đọc trong local storage
- Random post: Phần hiển thị các bài viết nhẫu nhiên
	Mỗi lần truy cập thì lấy nhẫu nhiên 3 bài viết hiển thị lên phần random post
	Có thể xây dựng thêm 1 số box khác như là bài viết được xem nhiều
	Keyword: js check is not defined

-----Xây dựng trang hiển thị chi tiết bài viết
- View type:
	Linh hoạt và tùy biến hiển thị của từng category	
	Thêm 1 thuộc tính nữa cho category để cho biết rằng category này hiển thị theo kiểu list hay kiểu Thumb(view_types:
		list, thumb)
	Admin Category
		List
		Thumb
	Views: Tách ra thành từng tập tin cho từng loại giao diện, đối với từng loại category sẽ kéo vào giao diện cho phù hợp

	Trang home:
		Thay vì hiển thị phần popular thì có thể lấy ra danh sách các bài viết trong từng category(mỗi category có thể chỉ
			lấy 1 bài viết)
		Không phải category cũng lấy mà trong bảng category thêm 1 thuộc tính nữa is_show_home(true/false) -> Có hiển thị 
		ở trang home hay không

- Get article: Hiển thị thông tin chi tiết của từng bài viết
	Gắn link cho các phần đã thự hiện
	Lấy thông tin chi tiết của bài viết
- Show article: Hiển thị thông tin chi tiết của 1 bài viết
	Prev Post: Bài viết trước bài này
	Next Post: Bài viết sau bài này
	-> Phù hợp với dạng các bài viết trong chuyên đề nào đó
		Bài 1: php cơ bản
		Bài 2: number
		Bài 3: Array
		--> Có thể xử lý theo thứ tự của các bài viết ordering
- Related article: Các bài viết trong cùng 1 category
	Các bài viết được lấy ra ko được bao gồm bài viết hiện tại
	Keyword: nodejs mongoose find id not equal

----------------------------------------------------------------------------------------------------
							Xây dựng nhóm chức năng quyền truy cập

-----Xây dựng chức năng đăng nhập vùng quản trị
- Page Login
	Chỉ khi nào người dùng đăng nhập thì mới cho họ truy cập vào vùng quản trị
	Bảng user -> có thêm username và password
	Muốn hoàn chỉnh thì trong phần quản lý user cần có thêm cột user, bổ sung thêm chức năng thêm mới user
	layout mới cho trang login khác với backend và frontend
	auth.js
	http://localhost:6969/admin/auth/login
	username: admin
	password: 123456
- passport config:
	Khi đăng nhập -> kiểm tra thông tin đăng nhập username và password có khớp hay không -> nếu đúng thì cho đăng
	nhập và lưu Session thông tin người đăng nhập
	Sử dụng package là passportjs giúp các vấn đề thực hiện các thao tác đăng nhập
	Site: http://www.passportjs.org/docs/authenticate/
	keyword: nodejs passport example
	Cài đặt: npm install passport
	Cơ chế đăng nhập thông qua username và password
	Config:
		var passport = require('passport');
		var LocalStrategy = require('passport-local').Strategy;
		passport.authenticate('local', { 
			successRedirect: linkIndex,
			failureRedirect: linkLogin,
			failureFlash: true
		})(req, res, next);
			(req, res, next): Cần phải truyền
	app.js
		const passport = require('passport');
		app.use(passport.initialize());
		app.use(passport.session());
 - Check login:
	Tiến hành kiểm tra thông tin xem nó có hợp nệ hay không
	Xây dựng thêm phương thức mới là getItemByUserName() trong phần Model user, tìm kiếm thông tin của user theo
		username
	Trong trường hợp username nhập vào có tồn tại trong db thì cần mã hóa mật khẩu nhập vào và so sánh với mật
		khẩu được lưu trong db xem có trùng khớp hay không
	Keyword: nodejs md5
	npm install md5
	Xử lý các tình huống user không tông tại, user tồn tại nhưng mật khẩu không đúng
	md5(123456): e10adc3949ba59abbe56e057f20f883e
- Login Logout:
	Xử lý khi nhập thông tin đúng rồi nhưng lại gây ra lỗi Failed to serialize user into session
		-> Bổ sung thêm 2 phương thức passport.serializeUser() và passport.deserializeUser()
	Sau khi login xong -> bổ sung thêm logout
	Sau khi logout thì chuyển đến trang login
	Khai báo thời gian tồn tại của cookie: 5 phút
	cookie: {
		maxAge: 5*60*1000
	}

	Đăng nhập user và sử dụng Json Web Token
		Mã hóa 1 object thành 1 string 
		npm install jsonwebtoken
		const jwt = require('jsonwebtoken')//Mã hoá 1 jsonObject thành token(string)
		localStorage: Sau khi đăng nhập xong lưu giá trị token vào trong localStorage
		Test:
			http://localhost:6969/admin/items
			http://localhost:6969/admin/article
	Đã đăng nhập rồi mà vào trang login thì redirect về trang dashboard
- Flash message:
	Hiển thị các thông tin thông báo khi mà người dùng nhập sai thông tin khi đăng nhập
	Sử dụng connect-flash để hiển thị ra câu thông báo lỗi
	npm install connect-flash
	Khai báo sử dụng: app.use(flash())
	Fix lại phần hiển thị các câu thông báo khi thực hiện thay thế flash cũ bằng connect-flash
		express-flash-notification -> connect-flash
	Cấu hình cũ của flash cũng bỏ đi và thay bằng cấu hình flash mới
		app.use(flash(app, {
			viewName: __path_views_admin + 'elements/notify'
		}))
		↓
		app.use(flash());
	Các thao tác để lưu vào trong Session
		req.flash('success', message); khi thực hiện thao tác redirect
		res.render('index', { messages: req.flash('info') }); Khi render ra view
	app.use(function(req, res, next) {
		res.locals.messages = req.flash();
		next();
	});
	Truyền messages ra ngoài
	notify.ejs: Duyệt qua các phần tử trong messages để in ra ngoài
		<% Object.keys(messages).forEach(function(type) { %>
			<div class="alert alert-<%= ((type === 'error') ? 'danger' : type ) %>" role="alert">
				<% messages[type].forEach(function(message) { %>
					<span class="close-btn">&times;</span><%= message %>
				<% }) %>
			</div>
		<% }) %>
	Bổ sung thêm link logout cho phần navbar default bên tay trái
	https://stackoverflow.com/questions/23160743/how-to-send-flash-messages-in-express-4-0
*(Use: Ban đầu vào ứng dụng)
	Cài đặt nodemon: npm install -g nodemon
	npm start
	var port = normalizePort(process.env.PORT || '6969');
	app.set('port', port);
Permission: Giới hạn người truy cập vào trong phần quản trị Admin
	Đối với vùng quản trị thì không phải người nào đăng nhập cũng cho truy cập vào vùng quản trị mà chỉ 
		có người dùng admin mới có quyền truy cập 
	Làm đúng yêu cầu thì chỉ có những người dùng nào có Group ACP là true thì mới được truy cập Admin

----------------------------------------------------------------------------------------------------
							Tối ưu và hoàn chỉnh phần frontend

Login
	Login không nên để ở trong admin mà đưa ra phần frontend
	helper formatLink() thực hiện loại bỏ đi dấu "/" ở vị trí đầu tiên khi link có 2 dấu "/" ở vị trí đầu tiên 
	req.flash('danger', notify.ERROR_LOGIN ); 
	res.redirect(linkLogin);
		Gửi thông báo đăng nhập sai và hiển thị lên câu thông báo thông tin đăng nhập sai
	Middleware get-user-info để truyền dữ liệu ra phần View
	Passing variables to the next middleware using next() in Express.js
		res.locals.userInfo = user;
			Tryền giá trị ra view 
Show user menu
	Trang frontend: Nếu mà người dùng đã đăng nhập rồi thì hiển thị Button Logout
		Khi chưa đăng nhập thì hiển thị Login 
		Nếu mà người dùng đã đăng nhập và có quyền truy cập vào vùng quản trị admin thì thêm link để truy cập vào 
			vùng Admin
	Kiểm tra 1 đối tượng có rỗng không
		Object.keys(userInfo).length > 0
Category for menu
	Các trang lấy ra danh sách Category đó là: Home, About, Article, Category, Contact
	Giải phải để chỉ thực hiện lấy danh sách category 1 lần -> Middleware
Article randmom
	itemsRandom cũng được dùng chung ở nhiều chỗ -> Xây dựng middleware cho itemsRandom
No permission
	Ở trang Error thì cũng ko cần lấy ra Category vì đã lấy ra ở Middleware rồi
	No Permission cũng dùng layout giống như trang Error
		layout: layoutBlog
	router.get('/no-permission', middleGetUserInfo, middleGetCategoryForMenu, middleArticleRandom, function(req, res, next) {
		res.render(folderView + '/no-permission', { layout: layoutBlog, top_post: false });
	});
Publish
	Port: 8181
	Tiến hành đưa sản phẩm lên hosting
	keyword: nodejs deploy
	App: nodejs-ver2
	-> Open app: https://nodejs-ver2.herokuapp.com/(link truy cập)
		trang Admin: https://nodejs-ver2.herokuapp.com/admin/items
	Sau khi cài đặt Heroku CLI vào thư mục dự án cần deploy và thực hiện các câu lệnh từ heroku login để deploy
	heroku logs: Lệnh để debug khi có lỗi khi deploy

	Install the Heroku CLI
	Download and install the Heroku CLI.

	If you haven't already, log in to your Heroku account and follow the prompts to create a new SSH public key.

	$ heroku login
	Clone the repository
	Use Git to clone project-nodejs-ver1's source code to your local machine.

	$ heroku git:clone -a project-nodejs-ver1
	$ cd project-nodejs-ver1
	Deploy your changes
	Make some changes to the code you just cloned and deploy them to Heroku using Git.

	$ git add .
	$ git commit -am "make it better"
	$ git push heroku master

	Sau khi push thành công quay lại trang ứng dụng của ta: https://project-nodejs-ver1.herokuapp.com/
	Để xem log lỗi xảy ra: heroku logs --tail
	-> nodemon: not found
	Do đó cần sửa lại trong package.json:
		"start": "nodemon ./bin/www" -> "start": "node ./bin/www"
	Rồi tiến hành commit và push lên heroku
	Error: Failed to lookup view "pages/publish/index" in views directory "/app/views"
		-> Fix home.js trong routes
	
	URL: https://nodejs-ver2.herokuapp.com/
	
======================================================================================================
										Ver 3
======================================================================================================
							SocketIO với các tình huống sử dụng
SocketIO
	SocketIO dùng để xây dựng các ứng dụng Realtime như: Chat, game online, tỉ giá, giao dịch tiền tệ, đấu giá 
		trực tuyến...
	Một mình SocketIO thì không thể làm được mà phải dùng nó kết hợp với các ngôn ngữ khác để xây dụng như: 
		PHP, ASP, NodeJs, Java ...
	