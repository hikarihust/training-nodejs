
									Training Nodejs
	
------------------------------------------------------------------------------------------------------------
	
- Cài đặt Nodejs:
	Truy cập vào trang web của nodejs: https://nodejs.org/en/ rồi tải về phiên bản Recommended For Most Users
		rồi cài đặt
	Sau khi kết thúc phần cài đặt, để kiểm tra xem phần cài đặt có thành công hay không thì có thể dùng CMD,
		Windows PowerShell hoặc sử dụng Git Bash để kiểm tra bằng câu lệnh: node -v
	Dùng câu lệnh npm -v để kiểm tra phiên bản(Node Package Manager), khi sử dụng nodejs thì cần cài thêm các 
		package vào --> npm giúp ta cài thêm các package vào. Khi cài đặt node thì nó sẽ tự động cài thêm npm
		
- Hello NodeJS:
	Để thực thi chương trình trên Visual Studio Code thì sử dụng phím tắt là Ctrl + `
	https://nodejs.org --> DOCS --> Guides --> tạo 1 tập tin là app.js và thực thi chương trình bằng câu lệnh 
		node app.js --> Truy cập http://127.0.0.1:3000/ <--> http://localhost:3000
	const http = require('http'): Nodejs nó là tập hợp của rất nhiều module, có rất nhiều module được xây dựng
		sẵn, khi muốn sử dụng module nào thì sử dụng require + tên của module
	http.createServer(): Tạo ra Server
		req: Request là gì
		res: Response là gì
		res.end('Hello World\n') --> Trả về kết quả là 'Hello World\n'
	Ngắt kết nối: Ctrl + C
	
- Module:
	Tự viết 1 module và gọi vào để dùng.
	module.exports: Để dùng được module này thì cần phải exports ra
	Ở bên tập tin cần sử dụng phải kéo module đó vào bằng require
	listen(moduleOne.port): Các tham số ở đằng sau như hostname hay Error function thì nó sẽ sử dụng các giá trị
		mặc định
		
- Output HTML tag:
	Cách trả về 1 đoạn HTML hay 1 trang HTML
	require('./mmodule/config'): cùng thư mực với mmodule
	res.setHeader('Content-Type', 'text/text'): Xuất ra text
		res.end('<h1>Hello NodeJS</h1>');
	res.setHeader('Content-Type', 'text/html'): Xuất ra HTML
		res.end('<h1>Hello NodeJS</h1>');
		
- Sử dụng nodemon:
	Ở các phần trên cứ mỗi lần chỉnh sửa thì chúng ta phải ngắt server rồi sau đó chạy lại câu lệnh là node + tên
		tập tin(app.js)
	Để khi mà thay đổi tập tin mà không cần ngắt và chạy lại
	Keyword: nodemon npm
	Cách sử dụng nodemon: nodemon [your node app]
	
- Output HTML file: Đọc 1 tập tin HTML và xuất tập tin ra khi truy cập vào Site
	nodejs open html file
	fs.readFile(file[, options], callback)
	
- Routing:
	Vấn đề là làm sao để người dùng lấy được giá trị nhập trên URL ---> có thể dùng đến module mới đó là url
	Keyword liên quan: How to get the full url in Express?
	Giảm ngắn lại mã trong tập tin app.js --> Tách riêng code 1 số phần
	-->Viết gọn lại phần mã nguồn cho Routing 

			-----------------------------------------------------------------------------------------

										Express
-----> Là 1 Framework cho NodeJs

- Express generator:
	Site: https://expressjs.com/
	Express generator: Là 1 công cụ giúp ta tạo nhanh ra một ứng dụng trên Express
	Cách cài: npm install express-generator -g
	Cách tạo nhanh một ứng dụng: express --view=pug myapp
		--view: nó sẽ add vào 1 view engine, view engine này có thể là ejs|hbs|hjs|jade|pug|twig|vash
			như ở câu lệnh trên thì sẽ add vào view engine là pug
	Keyword: express template engine
	Trong phần này mình sẽ sử dụng template engine là ejs -> cài đặt: express --view=ejs project-nodejs
	Sau khi quá trình cài đặt kết thúc thì vào trong folder project-nodejs rồi chạy câu lệnh: npm install
	Khởi động server nodejs: npm start rồi sau đó vào http://localhost:3000/ để xem project được tạo ra

- Express structure:
	Tìm hiểu một số folder và tập tin khi mình tạo ra bằng Express generator
	Folder bin: có chứa tập tin là www. Kéo vào tập tin app và module http, và thực hiện khai báo port
		--> có thể thực hiên thay đổi được giá trị của port ở đây
	Folder node_modules: Khi sử dụng npm để cài đặt những thư viện, module để cài đặt về thì nó sẽ nằm 
		trong folder này(express, ejs)
		Khi mà thực hiện copy source code từ máy này sang máy khác thì chỉ cần Copy hết các tập tin và thư
			mục ngoại trừ thư mục node_modules này rồi sau đó dùng câu lệnh npm install để cài đặt --> nó 
			tạo ra folder node_modules và tự động download các package module về, chúng ta sử dụng các package
			module nào thì nó đều khai báo trong package.json
	Folder public: Là nơi chứa hình ảnh trong ứng dụng, js trong javascripts, css trong stylesheets
	Folder routes: Giúp ta khai báo các đường dẫn--> điều hướng đến các trang cần mở
	Folder views: Chứa các tập tin view
	Tập tin app.js: 
		Thực hiện kéo vào module express: var express = require('express')
		Tạo ra 1 app bằng cách sử dụng express: var app = express()
		app khai báo vị trí của folder views: app.set('views', path.join(__dirname, 'views')) , nếu mà mình 
			không muốn folder views có tên là views mà là tên khác thì chỉ cần cấu hình lại ở đây
		Cấu hình view engine: app.set('view engine', 'ejs')
		app.use(express.static(path.join(__dirname, 'public'))): Khai báo các tài nguyên về css, js, image thì
			vào bên trong folder public để lấy lên, nếu ko muốn để tên là public thì mình có thể đổi lại là được
		Khai báo sử dụng routes:
			app.use('/', indexRouter), trong đó: var indexRouter = require('./routes/index');
			app.use('/users', usersRouter), trong đó: var usersRouter = require('./routes/users');

- Nodemon: Ta muốn mỗi lần chỉnh sửa gì đó mà ko cần Stop lại server và khởi động lại server bằng npm start nữa
	mà nó sẽ tự động thực hiện --> cần phải sử dụng được nodemon trong Express generator.
	Keyword: Express generator auto restart
	Cài đặt nodemon: npm install -g nodemon
	Để sử dụng được nodemon:
		"scripts": {
			"start": "nodemon ./bin/www"
		},
	Start server bằng: npm start

- Sử dụng Router:
	Link: https://expressjs.com/en/guide/routing.html
	Route paths: Cũng có thể áp dụng biểu thức chính quy
		app.get('/ab(cd)?e', function (req, res) {
			res.send('ab(cd)?e')
		})
		--> đường dẫn sẽ match với các trường hợp là: /abe hoặc /abcde
	Route parameters: Tham số truyền trên URL
		Route path: /users/:userId/books/:bookId
		Request URL: http://localhost:3000/users/34/books/8989
		req.params: { "userId": "34", "bookId": "8989" }
		Xác định tham số truyền trên URL:
			app.get('/users/:userId/books/:bookId', function (req, res) {
				res.send(req.params)
			})
	Một số phương thức hay dùng khi sử dụng: res.redirect(), res.render(), res.send(), res.sendFile(), res.end()...

- Sử dụng View:
	Khi ta có 1 giao diện, làm thế nào để tích hợp vào project mình đang làm
	Hiểu cách thay đổi tập tin view cho từng Router khác nhau
	Để cho dễ dàng quản lý views thì trong folder views tạo thêm các folder để quản lý riêng cho các phần khác nhau
		chẳng hạn như: items, categories... --> Biết cách nhóm các view đối với các phần quản lý khác nhau
	Ở đây ta có itmes.js trong routes đóng vai trò giống như Controller
	---> Làm rõ hơn về cách sử dụng của Router và cách kéo view vào trong 1 Router nào đó.

- View - Include:
	Trong Folder views tạo thêm 1 folder nữa là elements
	Keyword: ejs include file
		cú pháp: <% include filename %>
	---> Biết cách kéo một tập tin vào bên trong một tập tin nào đó

- Kỹ thuật nhúng giao diện và module mở rộng: Tách giao diện thì mình sẽ tìm các phần giao diện chung để tách riêng ra
	--> Làm như vậy giúp ta thuận lợi khi maintain
	Tách giao diện phần navbar
	Cách Format code: chuyển về html --> chuột phải --> Format Document
	header: Tách riêng những phần nằm trong thẻ <head>
	script: Tách riêng những thẻ script được nhúng vào
	Để vào được các tập tin Css thì đường dẫn đúng là: http://localhost:6969/public/
	Khi tách các tập tin script và Header ra thì thứ tự bị thay đổi --> cần phải có base href để định lại đường dẫn
		đặt trong thẻ <head> ---> <base href="/">
	Keyword: html base href
	Folder pages: Để định nghĩa view của từng trang, quản lý các view chẳng hạn như qua lý các view dashboard, items
	Khi thay đổi vị trí của các tập tin view thì phần nội dung trong routes phần render() cũng phải thay đổi theo
	html format: Dùng để format code html
	Mỗi trang khác nhau thì có 1 Title khác nhau, nếu như mà thay đổi cấu trúc html của nó thì có bao nhiêu trang -> 
		phải thay đổi bấy nhiêu lần. Thay vì cứ mỗi trang mình phải lặp lại cấu trúc html của title thì mình sẽ tách nó
		ra thành 1 file riêng để khi mà khi thay đổi cấu trúc html dành cho title thì chỉ cần sửa ở 1 chỗ mà thôi
	In ra giá trị được truyền từ Router ra View: <%= pageTitle %>
	--> Tách ra thêm 1 phần quản lý title
	Keyword: ejs --> https://ejs.co/
	Nhúng giao diện cho phần add items
	Ở cứ mỗi trang thì mỗi view của nó tương đối là ít --> không cần Copy cấu trúc html của toàn bộ trang, nếu như mà 
		cấu trúc html của trang thay đổi thì mình phải đi tất cả các trang để thay đổi
		để tối ưu mã html thì ở mỗi trang, nó chỉ chứa mã html của chính nó --> mà ko cần chứa mã của toàn bộ trang
	Tùy thuộc vào việc mình sử dụng template engine là gì thì nó sẽ có package để tách được phần layouts ra
	Keyword: express-ejs-layouts --> https://www.npmjs.com/package/express-ejs-layouts
	Cài đặt: npm install express-ejs-layouts
	Khi cài đặt thành công thì kiểm tra trong file package.json và folder node_modules thì thấy nó đã có thêm 
		express-ejs-layouts
	Sau khi cài đặt xong thì import nó vào tập tin chạy chính app.js để sử dụng: 
		var expressLayouts = require('express-ejs-layouts');
	Thứ tự sắp xếp các module trong app.js:
		module của hệ thống 
		module cài thêm vào
		module tự viết
			var createError = require('http-errors');
			var express = require('express');
			var path = require('path');
			var cookieParser = require('cookie-parser');
			var logger = require('morgan');

			var expressLayouts = require('express-ejs-layouts');

			var indexRouter = require('./routes/index');
			var usersRouter = require('./routes/users');
	Khai báo sử dụng: app.use(expressLayouts);
	Set custom default layout: app.set('layout', 'layouts/layout');
	Tùy thuộc vào vị trí layout được đặt ở đâu thì tương ứng ta sẽ có đường dẫn, đường dẫn sẽ được tính từ Folder views
	In ra content: <%- body %>
	---> Trong app.js mình cài đặt express-ejs-layouts, khai báo sử dụng layout default là backend, trong backend thì 
		khai báo sử dụng cho phần content là <%- body %>

- Setup Router:
	Truy cập vào mỗi trang bằng cách gắn link
	Phần quản lý đường link thì mình có các đường link cho người quản trị và các đường link cho người sử dụng bình thường
		ở phần này mình sẽ xây dựng cho phần quản lý admin
	Theo cách viết ở trên thì trong file app.js mình cần import rất nhiều các Router vào, theo cách viết như vậy thì sẽ làm cho app.js
		có nhiều dòng. Ý tưởng ở đây là trong routes mình sẽ kéo các Router khác vào--> trong app.js mình chỉ cần kéo 
		file đại diện của từng phần(items, categories...) vào mà thôi, đồng thời giúp cho phần routes cũng rất dễ quản lý
		res.render('pages/home/index', { pageTitle: 'HomePage' }) --> Cách viết đúng
		res.render('/pages/home/index', { pageTitle: 'HomePage' }) --> Cách viết sai
	Đối với phần routes thì chia ra 2 phần là backend và frontend để dễ quản lý--> trong app.js chit cần import vào backend và
		frontend là được ---> đến khi thêm 1 view mới cho backend hoặc frontend thì chỉ cần viết trong routes/backend và
		routes/frontend rồi import và trong index của 2 thằng này là được

- Prefix Admin:
	Trong ứng dụng thì khả năng mở rộng, khả năng chuyển biến linh hoặt của nó phải cao
	Local variable: Là variable có thể sử dụng trong ứng dụng của mình
		app.locals.systemConfig = 'admin123'

- Error Page:
	Khi truy cập vào một đường dẫn không tồn tại --> phần error handler sẽ được gọi --> nó sẽ render về tập tin là error
		khi render ra trang error thì sẽ phát sinh lỗi bởi vì hiện tại app đang sử dụng layout là backend, layout này import
		vào title-page --> trong đây có sử đến pageTitle. Việc này dẫn đến khi render ra trang error thì nó chưa được truyền
		vào biến pageTitle --> lỗi bị phát sinh --> muốn không có lỗi thì khi render ra trang error thì chỉ cần truyền vào
		thêm biến pageTitle
	Có thể thay đổi cho trang Error như vị trí, nội dung hiển thị...

- Review NodeJS:
	Tìm hiểu cơ bản về nodejs
	Cơ bản về cách dùng ExpressJs
	routes: Phân ra thành folder backend dành cho Router cho phần quản trị backend
			frontend dành cho phần quản trị frontend
	views: Tách ra cho từng trang riêng
	Giảm thiểu mã nguồn trùng lặp bằng cách sử dụng layouts backend
	Ngoài việc sử dụng template engine là ejs mình cũng đã sử dụng thêm 1 module nữa đó là express-ejs-layouts

- Mlab:
	Site: https://mlab.com/
	MongoDB Atlas: https://www.mongodb.com/cloud/atlas
	Tạo được ra DB ra trong MongoDB

- MongoDB Connect: Biết cách kết nối vơi mongodb thông qua dịch vụ của mlab
	Cách kết nối với cơ sở dữ liệu sử dụng MongoDB
	Thư viện(package) phổ biến giúp ta có thể làm việc được với MongoDB đó là Mongoose
	Site: https://mongoosejs.com/
		  https://mongoosejs.com/docs/guide.html  --> Bắt đầu từ Quick Start
	Cài đặt: npm install mongoose
	Keyword: mongodb atlas connect node
		--> https://docs.atlas.mongodb.com/connect-to-cluster/
	Trước tiên thì cần thực hiện 1 số yêu cầu:
		Tạo project: Training
		Thực hiện thêm Cluster mới
			Cluster Name: Cluster0
		Whitelist: Thực hiện add IP address  ở tab Security --> Add IP Address --> Allow Access from Anywhere, 
			khi add chỉ cần thực hiện các thông số mặc định 0.0.0.0/0
		MongoDB User: Để truy cập được vào cluster thì cần phải add thêm MongoDB User để có thể truy cập vào các 
			CSDL mong muốn trên Atlas cluster. Tài khoản MongoDB User là khác với tài khoản Atlas users. MongoDB user
			là dùng để truy cập vào CSDL MongoDB, còn Atlas users là để login vào ứng dụng Atlas
			user: vuquang
			pass: Vudinhquang2202
			Phân quyền là: Read and write to any database
		Kết nối với Cluster: Connect Your Application

- MoogoDB Quickstart

- Mongoose basic:
	Thực hiện hiển thị danh sách các item -> Cần đến câu lệnh Sellect
	Để dễ quản lý -> tạo thêm thư mục schemas, mỗi Collection sẽ có 1 tập tin schema riêng: items, categories...
	Keyword: mongoose get all items
	Mongoose thực hiện các phương thức và kết quả trả về được truyền vào lmaf tham số của hàm callback, đồng thời
		Mongoose cũng có phương thức .then() để thực hiện tiếp theo bước truy vấn.
		Tất cả các hàm callback đều có dạng callback(error, result)
			Trong trường hợp có lỗi xảy ra thì tham số error sẽ trả về 1 error parameter và result là null
			Ngược lại nếu truy vấn thành công thì error trả về null và result là kết quả của câu query

- Get items: Thực hiện truy vấn dữ liệu item và truyền ra view
	Ở đây thì dữ liệu được đổ ra view /admin/items --> Trong routes của items phải thực hiện lấy ra các items trong
		DB rồi truyền ra view
	Keyword: javascript print object

- Foreach:
	Khi đổ dữ liệu items ra view sử dụng Foreach --> hiển thị dữ liệu ra phần list item
	Để hiện thị các thông báo lỗi trong trang error để kiểm tra lỗi khi code:
		<h1><%= message %></h1>
		<h2><%= error.status %></h2>
		<pre><%= error.stack %></pre> 

- Status Helper:
	Khi xây dựng thêm các phần quản lý khác như categories, video... thì trên các view nó cũng có phần Status, phần này	
		sẽ được lặp lại -> Xây dựng phần Helpers hỗ trợ cung cấp sinh ra mã HTML giúp cho việc maintain cũng dễ dàng
	Include helper đã viết: <% include ../../helpers/status %>

- Show status filter: Lọc items theo status active, inactive, all + hiện thị có bao nhiêu phần tử ở trạng thái đó
	-> Các thuộc tính của mỗi nút filter đó là: 
		name: All/Active/Inactive, count: 4, link: '#', class(khi click vào phần tử nào thì phần tử đó được active)

- Count by status:
	Đối với trường status thì có thể nó có rất nhiều trạng thái: active, unactive, public, trash... -> thiết lập giá trị
		cho trường này là các giá trị text

- Helper Show Filter Status:
	Xây dựng helper cho phần hiển thị phần Filter trên view

- Helper Create Filter Status:
	Viết helper để tạo ra phần Status Filter -> làm giảm thiểu mã nguồn trong routes
	Sử dụng phương thức countDocuments() thay cho phương thức count()

- Status router:
	Dựa vào URL có thể lấy được các giả trị status: all, active, inactive, rồi từ đó hiện thị các giá trị theo Status
		đồng thời add class Css vào cho các nút Filter theo Status
	Cách ghi tổng quát cho status
		router.get('/:status', (req, res, next) => {
			res.write('test');
			res.end();
		});
	Cách lấy giá trị của status: req.params.status
	(/:status)?  -> trên URL thì giá trị này có thể xuất hiện hoặc không

- Active filter:
	Active cho các button Filter Status khi click vào các button đó để chuyển trang
	Hiện thị status khi hiện thị list các item

- List by status:
	Dựa vào trạng thái status ở trên URL mà mình sẽ đổ danh sách item ra ở phần list

- getParam:
	Khi mà không lấy được status từ URL, hoặc là giá trị của nó bằng rỗng thì gán giá trị mặc định cho nó là all
		nếu mà nó có tồn tại thì lấy giá trị của nó bình thường
	Keyword: javascript check object has property. javascript hasOwnProperty example
	--> Xử lý đế lấy giá trị: currentStatus
	Helper get param:
		let getParam = (params, property, defaultValue) => {
			if (params.hasOwnProperty(property) && params[property] !== undefined) {
				return params[property];
			}
			return defaultValue;
		}
		
- Filter Status - Error:
	Khi nhấn vào các filter status thì ta sẽ có các đường dẫn có dạng như:
		/status/active
		/status/inactive
		--> 'status' được bổ sung vào URL
	Error: Có lỗi bất đồng bộ xảy ra khi hiện thị giá trị count của mỗi status

- Submit keyword: Thực hiện lấy giá trị keyword nhập vào khi nhấn nút Submit
	Khi nhắn nút tìm kiếm thì giá trị keyword được gắn lên trên URL, sau đó lấy giá trị keyword trên URL xuống để tìm
		kiếm
	Tùy thuộc vào mình đang ở trạng thái nào mà ta có đường link tương ứng khi tìm kiếm: /items/all?keyword=abc
		--> Truyền giá trị status hiện tại ra view để gắn vào đường link
	Khi nhấn vào nút Search để tìm theo keyword thì giá trị keyword nhập vào vẫn phải được hiển thị trên ô input
		-> Trong routes mình cần lấy được keyword trên URL rồi truyền nó ra view
	app.use(logger('dev')) ---> comment để ẩn đi một số dòng hiển thị trong console

- Search normarl: Đưa ra trị keyword lấy được ra view -> đưa vào hiển thị trong ô input, và lọc các item theo keyword đó
	hiển thị ở phần view

- Search RE: Tìm kiếm sử dụng đến Regular Expression
	keyword: mongoose Regular Expression, mongoose find regex
	objWhere = {name: { $regex: /socket/, $options: 'i' }}
		Tìm các giá trị có chứa giá trị 'socket' và không phân biệt chữ hoa, chữ thường
	objWhere = {name: new RegExp(keyword, 'i')};

- Clear & Reset: 
	Clear: Nhấn vào nút Clear để thực hiện xóa việc tìm kiếm -> quay về trạng thái ban đầu không thực tìm kiếm theo
	keyword
		Cách 1: Khi nhấn vào nút Clear thì thực hiện xóa giá trị trong ô input và thực hiện Submit Form
		Cách 2: Gắn link vào cho nút Clear, khi mà nhấn nút Clear thì quay về trang với status hiện tại
	Refresh: Vừa Reset phần Search -> không tìm kiếm theo status, vừa Reset theo status -> status được Reset về giá trị
		default là All
		-> Cách làm giống như là nút Clear, nhưng ở đây ta có status là All

- Update Filter status link:
	Khi thực hiện tìm kiếm theo keyword, người dùng nhấn vào nút chuyển trạng thái -> giá trị keyword vẫn phải được giữ
		nguyên trong ô input

---------------------------------------------------------------------------------------------

							Xây Dựng Chức Năng Phân Trang	

- Sort Helper:	Khi lấy dữ liệu ra thì mình cần có sự sắp xếp
	<%- %>: In ra mã HTML
	<%= %>: In ra giá trị của 1 biến 
	--> Khi return về mã HTML mà mình muốn in nó ra thì dùng <%- %>
	keyword: mongoose sort by date -> sort()
	Ở mỗi phần(item, user, group, category...) nếu chúng đều có phần phân trang -> Xây dựng Helper cho phần phân trang

- Fix Helper Status:
	`` ----> ${link}
	Sửa Helper cho phần status
	Sửa Helper cho phần filterStatus

- List by page:
	Cần xác định được có bao nhiêu phần tử trên một trang(limit)	-> Cấu hình
	Cần biết đang ở trang nào để biết là lấy từ phần tử nào(skip) --> Lấy trên URL
	keyword: javascript convert string to int
	skip:(currentPage -1)*totalItemsPerPage

- Total Items:
	Thống kê tổng cộng có bao nhiêu phần tử
	Tổng cộng có bao nhiêu trang
	Khi tìm kiếm cũng phải lọc theo Status và keyword

- Number:
	Thống kê tổng số trang: totalItems/totalItemsPerPage
	Tổng số phần tử trên một trang
	Ở trang hiện tại hiển thị phần tử nào đến phần tử nào: from -> to
		Nếu mà to > totalItems thì gán to = totalItems

- Start, Previous:
	Nút Start: Có thể có link hoặc không
		Nếu không phải trang đầu tiên -> có link
		Nếu là trang đầu tiên thì nó có link(disable)
	Nút Previous: 
		Khi đang ở trang 1 thì không cần có link
		Khi ở từ trang 2 trở đi thì cần có link

- Next, End: Xây dựng cũng tương tự như 2 nút Start và Previous
	Nếu trang hiện tại không phải trang cuối cùng thì gắn link cho Next và End
	Nếu mà đang ở trang đầu tiên thì không cần hiển thị 2 nút Start và Previous
	Nếu đang ở trang cuối cùng thì không cần hiển thị 2 trang Next và End
	--> Ban đầu gắn cho nó các giá trị là rỗng
	keyword: javascript declare multi variable --> Định nghĩa nhiều variable trên cùng 1 dòng

- Pages: Xây dựng phần giao diện để hiện thị những con số ở phần phân trang
	Cần có thêm phần active, chẳng hạn như nếu đang ỏ trang 3 thì ở 3 không cần gắn link cho nó và gắn thêm cho nó
		thêm 1 class(active)
	Tham khảo thêm cấu tạo của phần phân trang của Bootstrap 3

- Pagerange: Giới hạn số trang hiển thị ở phần hiển thị các con số
	-> Thiết lập thêm là muốn hiện thị lên bao nhiêu trang, thay vì có bao nhiêu trang thì hiện thị lên hết bấy 
		nhiêu trang
	VD: totalItems = 15, totalItemsPerPage = 2 -> totalPage = 8, pageRange = 5 -> midle = 5/2 = 3
		currentPage		xhtmlPages								 min = currentPage - midle + 1     max	= min + pageRange -1
		1				1 2 3 4 5									  1 - 3 + 1 = -1 <= 1 -> 1	   5				
		2				1 2 3 4 5									  2 - 3 + 1	= 0	 <= 1 -> 1	   5
		3				1 2 3 4 5									  3 - 3 + 1	= 1	 <= 1 -> 1     5

		4				2 3 4 5 6 -> currentPage nằm ở giữa		--	  4 - 3 + 1	= 2  			   6	 = 2 + 5 -1
		5				3 4 5 6 7 -> currentPage nằm ở giữa		--	  5 - 3 + 1	= 3				   7	 = 3 + 5 -1

		6				4 5 6 7 8									  6 - 3 + 1	= 4   -> 4		   8	   4 + 5 -1	= totalPage -> totalPage
		7				4 5 6 7 8									  7 - 3 + 1	= 5	  -> 4		   8	   5 + 5 -1 > totalPage -> totalPage
		8				4 5 6 7 8									  8 - 3 + 1	= 6   -> 4		   8	   6 + 5 -1 > totalPage -> totalPage
		--> Giá trị đầu và cuối sẽ thay đổi tùy thuộc vào giá trị của currentPage
			Do đó mình sẽ đặt ra 2 giá trị là min và max(của dãy số nằm trong pageRange)
			-> Cần xác định 2 giá trị min và max

- Fix pagination: Hoàn thiện cho phần phân trang
	Giải quyết trường hợp khi totalPages nhỏ hơn hoặc bằng giá trị thiết lập pageRanges -> min sẽ có giá trị là 1
	Khi nếu chỉ có 1 trang thôi thì không cần hiển thị cũng được --> xhtmlPagination = ''

- Link pagination:
	Giữ lại trạng thái lọc theo Status, cũng như giá trị tìm kiếm khi chuyển sang trang khác -> truyền giá trị Status
		ra helper pagination	
	Có cách sử lý khác đó là đưa các giá trị Status và keyword vào trong Session
	Phần quản lý pagination sẽ là phần dùng chung cho nhiều các phần quản lý khác: items, user, category -> để tổng quát
		hơn thì ở phần tạo link của pagination cần thêm 1 variable là type(items, user, category) -> dễ dàng tái sử dụng 
		mã nguồn	

- Link change status: Thay đổi trạng thái của 1 phần tử nào đó
	admin/items/change-status/12/active -> lấy được id và status của phần tử hiện tại
	res.send('test'): Truyền ra browser giá trị là 'test'

----------------------------------------------------------------------------------------------------

- Change status:
	Từ giá trị id và Status tiến hành cập nhật lại status cho item
	active <-> inactive
	keyword: Mongoose updateOne
	then()
	res.redirect() ---------res: Response
	Chỉnh sửa cho phần Change status bằng cách khi redirect về trang items thì ko fix cứng giá trị admin trong đường dẫn
		mà sử dụng giá trị trong config

- Delete item: Thực hiện chức năng là xóa 1 phần tử nào đó
	deleteOne()
	const linkIndex: Khai báo biến link cho index để có thể dùng chung cho các route

- Xây dựng chức năng Change Status cho nhiều phần tử:
	Chọn những phần tử mà mình muốn thay đổi trạng thái cho nó
	Chọn trạng thái muốn thay đổi
	Nhấn Apply
	Khi vừa vào trang thì nút Apply không Click được(vì chưa chọn hành động)
	Nếu nhấn nút Apply khi chưa chọn phần tử nào thì sẽ hiện lên câu thông báo yêu cầu chọn phần tử để thay đổi
	change_form_action: Chứa 3 tham số
		Tham số thứ nhất: Sellect box. Trong các option của Sellect Box thì lưu trực tiếp link mình muốn Submit đến
		Tham số thứ 2: Form -> chứa cả các input là checkbox, để khi mà Form Submit đi Form sẽ nhận được các giá trị 
			checkbox đó -> biết phần tử muốn thay đổi là phần tử nào
		Tham số thứ 3: Nút Apply
	test() trong javascript: Kiểm tra 1 giá trị nào đó có nằm trong 1 chuỗi hay không
	Form để method là post
	console.log(req.body): Kiểm tra các giá trị có trong req -> giúp ta lấy được các dữ liệu gửi từ Form
	keyword: mongoose update many, mongo update many
	https://docs.mongodb.com/manual/reference/operator/query/#query-selectors

- Delete multi item:
	Khi nhấn Apply để Delete thì hộp thoại để xác nhận được hiện lên
	Cần lấy được danh sách các id của item mà người dùng muốn xóa
	remove()

- Change ordering: Xây dựng chức năng Change Ordering của nhiều phần tử:
	Nhập giá trị mới cho ordering
	checkbox
	Chọn Change Ordering và nhấn nút Apply
	-> Có id và các giá trị ordering của các item muốn thay đổi
	Phần tử được check: $(".ordering").attr("name", "ordering")
	Phần tử không được check: $(".ordering").removeAttr("name")
	Có 2 trường hợp cập nhật đó là: Cập nhật 1 item và cập nhật nhiều item
	keyword: mongoose updateMany() -> giá trị update là cố định
	Cấu trúc từ phần Select, Button Apply và Button Add New khi mà qua các phần quản lý khác như quản lý User, quản
		lý group... sẽ tiếp tục lặp lại cấu trúc html đó -> tạo mới helper
	filterStatusHelper(): Thêm 1 tham số mới đó là collection rồi truyền vào giá trị là items
	actionHelper(): Để tạo mã html cho phần thay đổi status, ordering, delete

- Show messsage: Xây dựng chức năng hiển thị thông báo khi thực hiện xong 1 hành động nào đó
	keyword: nodejs express show notification
			express session
			setTimeout(): Thực hiện 1 hàm hay 1 biểu thức nào đó do mình viết sau 1 khoảng time nào đó
	site: https://www.npmjs.com/package/express-flash-notification
		https://www.npmjs.com/package/express-session
	Cài đặt: npm i express-flash-notification --save
	Copy:
		Trước: const app = express()
			const flash = require('express-flash-notification');
			const cookieParser = require('cookie-parser');
			const session = require('express-session');
		Sau: const app = express()
			app.use(cookieParser());
			app.use(session({...}}));
			app.use(flash(app));
	Express session:
		app.use(session({
			secret: 'qtgbjhyd',
			resave: false,
			saveUninitialized: true,
		}));
	Lỗi: Cannot find module 'express-session' 
		->Fix: npm install express-session
	In ra câu thông báo ở ngoài layout: <%- locals.flash %>
	Định nghĩa câu thông báo: req.flash('info', 'invalid username or password');
	Lỗi: Failed to lookup view "flash" in views directory "C:\xampp\htdocs\training-nodejs\project-nodejs\views"
	-> cần tạo ra 1 view flash.ejs trong thư mục views:
		<div class="alert flash">
			<button type="button" class="close">×</button>
			<i class="fa sign"></i><strong><%= type %></strong>
			<span><%= message %></span>
		</div>
	type: Ta có các loại thông báo như là thông báo thành công, lỗi: success, warning, danger...
	Error: Cannot set headers after they are sent to the client
		req.flash(String type, String message, Boolean renderInThisRequest) 
		->Trong trường hợp này thì change status, delete... không cần phải render -> renderInThisRequest có giá 
			trị là false
	Trường hợp mà cập nhật nhiều phần tử -> đưa ra cả số lượng phần tử được cập nhật
		keyword: mongoose update many get number of documents
	Hiện nay tập tin hiện thị câu thông báo đang mặc định tên là flash -> có thể thay đổi tên,
		cũng như là thay đổi vị trí đặt tập tin
		-> Khi sử dụng flash thì ngoài việc truyền vào app thì cần truyền thêm 1 đối tượng cấu hình các thông số

- Add item: Xây dựng chức năng Add phần tử
	form.ejs: Phần add và edit sẽ dùng chung 1 tập tin view
		add: form
		edit: form/id -> từ id lấy được các giá trị liên quan đến item đó rồi đổ ra lên trên view
	Kiểm tra URL nếu như mà có id thì nó là Form để Edit, còn nếu như mà không có id thì đó là trường hợp thêm mới
	Khi edit, ban đầu trang sẽ hiển thị đầy đủ thông tin của item cần edit -> cần lấy ra thông tin của phần tử
	Error: item.setPrototypeOf is not a function 
	keyword: req.body hasOwnProperty is not define
		Do đối tượng item đã được gán trực tiếp giá trị của req.body có dạng: 
			[Object: null prototype] { name: 'ABC 123', ordering: '123', status: 'active', id: '' }
	Fix: Để khắc phục lỗi này thì không nên gán từ req.body 
		hoặc parse ra obj: req.body = JSON.parse(JSON.stringify(req.body));

- Xây dựng chức năng Validator:
	keyword: nodejs express validator
	Installation: npm install express-validator
	Kéo vào app.js để sử dụng: const flash = require('express-validator');
	errors = req.validationErrors(): Giá trị là false khi không có lỗi, nếu có lỗi thì nó là 1 array chứa phần tử ở 
		bên trong

- Validator: Thực hiện validate khi add item
	keyword: express validator check interger, express validator check not equal
	Tự xây dựng một validator riêng:
		Cách 1: router
			req.checkBody('status', 'Phải chọn status').custom(() => {
				if (req.body.status !== 'novalue') {
					return true;
				} else {
					return false;
				}
			});
		Cách 2: router và app
			app.use(validator(
				{
					customValidators:{
						isNotEqual: (val1, val2) =>{
							return val1 !== val2;
						}
					}
				}
			));
			req.checkBody('status', 'Phải chọn status').isNotEqual('novalue');

- Show Error: Thực hiện hiển thị các câu thông báo lỗi khi có lỗi xả ra
	Khi add dữ liệu mà có lỗi xảy ra thì vẫn ở lại trang Form và hiển thị lỗi lên trên trang đó
		-> Truyền giá trị errors lên trên view
	Xây dựng element riêng để hiện thị errors trên Form
	keyword: javascript uppercase first letter
	Object.assign(): được sử dụng để sao chép các giá trị của tất cả thuộc tính có thể liệt kê từ 
		một hoặc nhiều đối tượng nguồn đến một đối tượng đích. Nó sẽ  trả về đối tượng đích đó.

- Edit item: Edit thông tin của 1 phần tử nào đó
	Dựa vào giá trị id trong ô input rỗng được truyền đi từ form để phân biệt trường hợp Add và Edit

----------------------------------------------------------------------------------------------------

							Tối Ưu Và Hoàn Chỉnh Phần Quản Lý

- Notify: Sau khi thực hiện thành công 1 tác vụ nào đó -> hiện thị ra câu thông báo
	Khi quản lý các phần khác ko phải quản lý item thì các câu thông báo này cũng lặp đi lặp lại
	-> Tạo ra 1 tập tin để định nghĩa câu thông báo, điều này khiên việc muốn thay đổi nội dung câu 
		thông báo được thực hiện dễ dàng
	Hiện thị câu thông báo khi thay đổi status của nhiều item cùng 1 lúc:
	-> Sử dụng thư viện Utilities của Nodejs -> util.format()
	Hiện thị các câu thông báo khi Validate

- Folder view:
	Hiện tại thì item có 2 view đó là:
		form: pages/items/form
		list: pages/items/list
	-> Tổng quát hóa bằng cách đặt thêm biến folderView	 = 'pages/items/'

- Database config: Ở phần kết nối với mongodb thì nên tách ra thành 1 file cấu hình riêng để định nghĩa 
	các thông số database

- View: Khi tạo view cho các phần quản lý khác ngoài quản lý item thì để có thể sử dụng dễ dàng các view đã viết của item, 
	thì mình có thể thêm 1 số phần định nghĩa như sau trong list.ejs và form.ejs:
	const collection = 'items';
	const linkPrefix = systemConfig.prefixAdmin + '/' + collection + '/';

- Path: Có thể thay đổi tên folder/tập tin cũng như là vị trí của chúng(thay đổi cấu trúc thư mục) mà việc require chúng 
	được thực hiện dễ dàng
	keyword: nodejs define path
	-> Có nhiều giải pháp có thể sử dụng: https://gist.github.com/branneman/8048520
	Trong trường hợp này sử dụng Global
	Để cấu trúc tập tin của ta đỡ phức tạp và nhiều, dễ quản lý hơn. Ta tạo ra folder app để chứa mã nguồn mình sẽ viết
	Đặt phần cấu hình đường dẫn thành 1 tập tin riêng để dễ dàng quản lý

- Fix filter status: routes -> items.js
	Viết gọn mã nguồn đối với điều kiện lọc dữ liệu theo currentStatus và keyword

- Pagination: javascript đồng bộ và bất đồng bộ
	keyword: javascript promise, javascript async await
	Ở phần phân trang thì phải count số phần tử trước rồi mới thực hiện render ra view, nhưng vấn đề xảy ra là chưa thực
		hiện count xong thì phần render ở dưới nó đã thực Hiện
		Để khắc phục tình trạng này thì mình sử dụng async await
	-> Giải quyết được vấn đề lấy dữ liệu lên không kịp

- Fix filter status:
	Fix lỗi trong vấn đề hiển thị ở phần filterStatus đôi khi phần đếm bị sai, phần đếm số phần tử được đặt trong vòng lặp Foreach
		và đếm chưa thực hiện xong thì nó đã nhảy đến phần tử tiếp theo
	keyword: async await in Foreach
	Ở đây thì async await không dùng được với Foreach -> thay nó bằng for

----------------------------------------------------------------------------------------------------

- Publish:
	Tiến hành đưa sản phẩm lên hosting
	keyword: nodejs deploy
	App: project-nodejs-ver1

Install the Heroku CLI
Download and install the Heroku CLI.

If you haven't already, log in to your Heroku account and follow the prompts to create a new SSH public key.

$ heroku login
Clone the repository
Use Git to clone project-nodejs-ver1's source code to your local machine.

$ heroku git:clone -a project-nodejs-ver1
$ cd project-nodejs-ver1
Deploy your changes
Make some changes to the code you just cloned and deploy them to Heroku using Git.

$ git add .
$ git commit -am "make it better"
$ git push heroku master

Sau khi push thành công quay lại trang ứng dụng của ta: https://project-nodejs-ver1.herokuapp.com/
Để xem log lỗi xảy ra: heroku logs --tail
-> nodemon: not found
Do đó cần sửa lại trong package.json:
	"start": "nodemon ./bin/www" -> "start": "nodem ./bin/www"
Rồi tiến hành commit và push lên heroku
Error: Failed to lookup view "pages/publish/index" in views directory "/app/views"
	-> Fix home.js trong routes
Tương tự fix lỗi khi click vào dashboard

----------------------------------------------------------------------------------------------------
									Xây dựng trang quản lý Items nâng cao

- Add: Thêm mới thuộc tính created
	Tiếp tục thêm vào phần quản lý item phần tạo ra vào lúc nào và tạo ra bởi ai
	Để lưu được các nội dung này thì tạo thêm phần thuộc tính:
		created{
			user_id: ->created_by
			username -> tuy dư thừa dữ liệu nhưng khi trên phần quản lý item khi hiển thị thông tin người sửa
							sẽ không cần jion vào bảng user
			time:    ->created_at
		}
	Được chỉnh sửa lần cuối cùng bởi ai:
		modified{
			user_id: ->created_by
			username -> tuy dư thừa dữ liệu nhưng khi trên phần quản lý item khi hiển thị thông tin người sửa
							sẽ không cần jion vào bảng user
			time:    ->created_at
		}

- Edit - Status - Ordering:
	Lưu thông tin modified khi Edit status của 1 or nhiều phần tử, Edit ordering của 1 or nhiều phần tử hoặc khi
	thực hiện Edit phần tử

- Show date:
	Show thông tin modified và created lên trên view
	Thông tin item được tạo ra bởi người dùng nào, và time nào
	glyphicon -> Có thể sử dụng lệnh tắt của Bootstrap trên tập tin ejs
	-> EJS language support
	select('name status orderring created modified'): Giới hạn các thuộc tính lấy ra từ cơ sở dữ liệu
	moement: Thư viện của javascript để định dạng thời gian
	Cài đặt moment như 1 package dùng trong project: nodejs express moment
	keyword: Using Moment.js in Node.js
	Site: https://dzone.com/articles/using-momentjs-in-nodejs
		https://momentjs.com/
	Xây dựng helper để hiện thời gian theo format

- Sort: Thay đổi thứ tự sắp xếp trên view
	Tại 1 thời điểm thì chỉ sắp xếp theo 1 cột hoặc là name hoặc là ordering
	Có thể thực hiện bằng cách đưa lên URL: /colname=name&sorttype=desc
	...

- Link: 
	Tạo helper cho các phần tạo link cho phần sắp xếp
	Sắp xếp theo hướng nào thì giá trị hướng đó không phải do mình truyền vào mà là do sắp xếp hiện tại
		-> từ gia trị sắp xếp hiện tại suy ra được sắp xếp truyền vào link(hiện tại là asc thì truyền vào link
			là desc và ngược lại)

- Style: Thêm style để định dạng cho các cột khi tạo các phần sort
	sortHelper(collection, 'Name', 'name', sortField, sortType, 'width:20%')

- CKEditor: 
	Thêm thuộc tính mới về mô tả Item, nội dung này người dùng có thể định dạng chữ...
	-> Sử dụng ckeditor

- Save:
	Tiến hành validate thông tin có hợp nệ hay không
	Tiến hành lưu thông tin(có thêm content)

----------------------------------------------------------------------------------------------------
								Xây dựng nhóm chức năng quản lý người dùng

-----Xây dựng chức năng quyền truy cập của nhóm người dùng:
- Group CRUD: Copy và kế thừa từ quản lý Item

- Fix filterStatusHelper: Fix phần thống kê status của Group

- Save:
	group_acp: Có giá trị bằng 1 thì có thể truy cập được vào vùng quản trị 0 thì không có quyền truy Cập
		vùng quản trị
	Khi hiện thị thông báo lỗi: group_acp -> Group Acp

- Show Group ACP: Trên trang Group Managment thì hiện thị lên group nào là nhóm quản trị, nhóm nào không
	phải nhóm quản trị

- Change Group ACP: Thực hiện chức năng thay đổi Group ACP

- Fix linkPrefix: 
	Viết gọn lại code bằng cách 
		Trên view đã có sẵn const linkPrefix = systemConfig.prefixAdmin + '/' + collection + '/' -> truyền
		vào làm tham số trong các helper

-----Xây dựng trang quản lý người dùng:
- User CRUD: Tạo phần CRUD cho phần user

- get groupsItems, selectboxGroupsItems: Trong trường hợp này thì mình cũng lưu dư thừa dữ liệu
	group{id, name} -> do đó ở phần hiển thị user thì mình có thể hiển thị lên luôn tên group mà không cần join
	Khi thêm user mới thì có SelectBox để chọn user đó thuộc về group nào
	selectboxGroupsItems: Xây dựng 1 helper để tạo ra SelectBox trên view
	groupsItems.unshift(): Bổ sung thêm 1 phần tử mới vào đầu mảng

- Group - Validate:
	Ctrl + K + 0: đóng lại
	Ctrl + K + J: mở hết
	Khi mà submit validate chưa thành công thì giá trị group đã được chọn phải được giữ lại

 - Save: Lưu thông tin của người dùng khi mà biết thông tin group của người dùng đó

 - Edit: Edit thông tin user

 - selectboxGroup: 
 	Hiển thị thêm thông tin Group của user
	Lọc danh sách user theo group:
		Có nhiều cách để thực hiện: Giống như phần filter theo status, search, submitform...
		Ở đây thì mình dùng Session
	Session: Khi chọn 1 phần tử nào đó -> gửi đến 1 url nào đó, thực hiện lưu Session
	Khi chọn 1 nhóm nào đó mà không có phần tử nào thì hiện thị câu thông báo cho người sử dụng


-----Tối ưu mã phần xây dựng Model 
- listItem:
	Tối ưu mã nguồn và tách nhỏ các phần xử lý giúp cho việc maintain dễ hơn
	Tìm cách tách phần Model riêng để cho routes chỉ đóng vai trò như là Controller
	Liên quan đến lấy dữ liệu -> đặt trong Model

- changeStatus: Xây dựng phương thức changeStatus để thay đổi status của 1 phần tử và nhiều phần
	tử cùng 1 lúc

- changeOrdering: 
	Khi vòng for chạy xong để thay đổi ordering của các phần tử xong thì nó return lại 1 promise
	keyword: promise resolve reject return 

- delete & get:
	Xóa 1 hoặc nhiều phần tử
	Lấy thông tin phần tử hiện lên trên Form khi thực hiện Edit

- save: Save thông tin phần tử khi add và save

- GroupsModel: Xây dựng Model groups để quản lý groups

- UsersModel: Xây dựng Model users để quản lý users

-----Cập nhật đồng bộ thông tin nhóm người dùng
	Tên group ở đây ít bị thay đổi -> có thể sử dụng kỹ thuật dư thừa dữ liệu để lưu tên group trong 
		user
	Trong bảng users thì user có lưu cả thông tin nhóm người dùng, vì vậy để khi mà ta thay đổi
		thông tin nhóm người dùng -> trong user cũng phải cập nhật lại.