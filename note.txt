
									Training Nodejs
	
------------------------------------------------------------------------------------------------------------
	
- Cài đặt Nodejs:
	Truy cập vào trang web của nodejs: https://nodejs.org/en/ rồi tải về phiên bản Recommended For Most Users
		rồi cài đặt
	Sau khi kết thúc phần cài đặt, để kiểm tra xem phần cài đặt có thành công hay không thì có thể dùng CMD,
		Windows PowerShell hoặc sử dụng Git Bash để kiểm tra bằng câu lệnh: node -v
	Dùng câu lệnh npm -v để kiểm tra phiên bản(Node Package Manager), khi sử dụng nodejs thì cần cài thêm các 
		package vào --> npm giúp ta cài thêm các package vào. Khi cài đặt node thì nó sẽ tự động cài thêm npm
		
- Hello NodeJS:
	Để thực thi chương trình trên Visual Studio Code thì sử dụng phím tắt là Ctrl + `
	https://nodejs.org --> DOCS --> Guides --> tạo 1 tập tin là app.js và thực thi chương trình bằng câu lệnh 
		node app.js --> Truy cập http://127.0.0.1:3000/ <--> http://localhost:3000
	const http = require('http'): Nodejs nó là tập hợp của rất nhiều module, có rất nhiều module được xây dựng
		sẵn, khi muốn sử dụng module nào thì sử dụng require + tên của module
	http.createServer(): Tạo ra Server
		req: Request là gì
		res: Response là gì
		res.end('Hello World\n') --> Trả về kết quả là 'Hello World\n'
	Ngắt kết nối: Ctrl + C
	
- Module:
	Tự viết 1 module và gọi vào để dùng.
	module.exports: Để dùng được module này thì cần phải exports ra
	Ở bên tập tin cần sử dụng phải kéo module đó vào bằng require
	listen(moduleOne.port): Các tham số ở đằng sau như hostname hay Error function thì nó sẽ sử dụng các giá trị
		mặc định
		
- Output HTML tag:
	Cách trả về 1 đoạn HTML hay 1 trang HTML
	require('./mmodule/config'): cùng thư mực với mmodule
	res.setHeader('Content-Type', 'text/text'): Xuất ra text
		res.end('<h1>Hello NodeJS</h1>');
	res.setHeader('Content-Type', 'text/html'): Xuất ra HTML
		res.end('<h1>Hello NodeJS</h1>');
		
- Sử dụng nodemon:
	Ở các phần trên cứ mỗi lần chỉnh sửa thì chúng ta phải ngắt server rồi sau đó chạy lại câu lệnh là node + tên
		tập tin(app.js)
	Để khi mà thay đổi tập tin mà không cần ngắt và chạy lại
	Keyword: nodemon npm
	Cách sử dụng nodemon: nodemon [your node app]
	
- Output HTML file: Đọc 1 tập tin HTML và xuất tập tin ra khi truy cập vào Site
	nodejs open html file
	fs.readFile(file[, options], callback)
	
- Routing:
	Vấn đề là làm sao để người dùng lấy được giá trị nhập trên URL ---> có thể dùng đến module mới đó là url
	Keyword liên quan: How to get the full url in Express?
	Giảm ngắn lại mã trong tập tin app.js --> Tách riêng code 1 số phần
	-->Viết gọn lại phần mã nguồn cho Routing 

			-----------------------------------------------------------------------------------------

										Express
-----> Là 1 Framework cho NodeJs

- Express generator:
	Site: https://expressjs.com/
	Express generator: Là 1 công cụ giúp ta tạo nhanh ra một ứng dụng trên Express
	Cách cài: npm install express-generator -g
	Cách tạo nhanh một ứng dụng: express --view=pug myapp
		--view: nó sẽ add vào 1 view engine, view engine này có thể là ejs|hbs|hjs|jade|pug|twig|vash
			như ở câu lệnh trên thì sẽ add vào view engine là pug
	Keyword: express template engine
	Trong phần này mình sẽ sử dụng template engine là ejs -> cài đặt: express --view=ejs project-nodejs
	Sau khi quá trình cài đặt kết thúc thì vào trong folder project-nodejs rồi chạy câu lệnh: npm install
	Khởi động server nodejs: npm start rồi sau đó vào http://localhost:3000/ để xem project được tạo ra

- Express structure:
	Tìm hiểu một số folder và tập tin khi mình tạo ra bằng Express generator
	Folder bin: có chứa tập tin là www. Kéo vào tập tin app và module http, và thực hiện khai báo port
		--> có thể thực hiên thay đổi được giá trị của port ở đây
	Folder node_modules: Khi sử dụng npm để cài đặt những thư viện, module để cài đặt về thì nó sẽ nằm 
		trong folder này(express, ejs)
		Khi mà thực hiện copy source code từ máy này sang máy khác thì chỉ cần Copy hết các tập tin và thư
			mục ngoại trừ thư mục node_modules này rồi sau đó dùng câu lệnh npm install để cài đặt --> nó 
			tạo ra folder node_modules và tự động download các package module về, chúng ta sử dụng các package
			module nào thì nó đều khai báo trong package.json
	Folder public: Là nơi chứa hình ảnh trong ứng dụng, js trong javascripts, css trong stylesheets
	Folder routes: Giúp ta khai báo các đường dẫn--> điều hướng đến các trang cần mở
	Folder views: Chứa các tập tin view
	Tập tin app.js: 
		Thực hiện kéo vào module express: var express = require('express')
		Tạo ra 1 app bằng cách sử dụng express: var app = express()
		app khai báo vị trí của folder views: app.set('views', path.join(__dirname, 'views')) , nếu mà mình 
			không muốn folder views có tên là views mà là tên khác thì chỉ cần cấu hình lại ở đây
		Cấu hình view engine: app.set('view engine', 'ejs')
		app.use(express.static(path.join(__dirname, 'public'))): Khai báo các tài nguyên về css, js, image thì
			vào bên trong folder public để lấy lên, nếu ko muốn để tên là public thì mình có thể đổi lại là được
		Khai báo sử dụng routes:
			app.use('/', indexRouter), trong đó: var indexRouter = require('./routes/index');
			app.use('/users', usersRouter), trong đó: var usersRouter = require('./routes/users');

- Nodemon: Ta muốn mỗi lần chỉnh sửa gì đó mà ko cần Stop lại server và khởi động lại server bằng npm start nữa
	mà nó sẽ tự động thực hiện --> cần phải sử dụng được nodemon trong Express generator.
	Keyword: Express generator auto restart
	Cài đặt nodemon: npm install -g nodemon
	Để sử dụng được nodemon:
		"scripts": {
			"start": "nodemon ./bin/www"
		},
	Start server bằng: npm start

- Sử dụng Router:
	Link: https://expressjs.com/en/guide/routing.html
	Route paths: Cũng có thể áp dụng biểu thức chính quy
		app.get('/ab(cd)?e', function (req, res) {
			res.send('ab(cd)?e')
		})
		--> đường dẫn sẽ match với các trường hợp là: /abe hoặc /abcde
	Route parameters: Tham số truyền trên URL
		Route path: /users/:userId/books/:bookId
		Request URL: http://localhost:3000/users/34/books/8989
		req.params: { "userId": "34", "bookId": "8989" }
		Xác định tham số truyền trên URL:
			app.get('/users/:userId/books/:bookId', function (req, res) {
				res.send(req.params)
			})
	Một số phương thức hay dùng khi sử dụng: res.redirect(), res.render(), res.send(), res.sendFile(), res.end()...

- Sử dụng View:
	Khi ta có 1 giao diện, làm thế nào để tích hợp vào project mình đang làm
	Hiểu cách thay đổi tập tin view cho từng Router khác nhau
	Để cho dễ dàng quản lý views thì trong folder views tạo thêm các folder để quản lý riêng cho các phần khác nhau
		chẳng hạn như: items, categories... --> Biết cách nhóm các view đối với các phần quản lý khác nhau
	Ở đây ta có itmes.js trong routes đóng vai trò giống như Controller
	---> Làm rõ hơn về cách sử dụng của Router và cách kéo view vào trong 1 Router nào đó.

- View - Include:
	Trong Folder views tạo thêm 1 folder nữa là elements
	Keyword: ejs include file
		cú pháp: <% include filename %>
	---> Biết cách kéo một tập tin vào bên trong một tập tin nào đó

- Kỹ thuật nhúng giao diện và module mở rộng: Tách giao diện thì mình sẽ tìm các phần giao diện chung để tách riêng ra
	--> Làm như vậy giúp ta thuận lợi khi maintain
	Tách giao diện phần navbar
	Cách Format code: chuyển về html --> chuột phải --> Format Document
	header: Tách riêng những phần nằm trong thẻ <head>
	script: Tách riêng những thẻ script được nhúng vào
	Để vào được các tập tin Css thì đường dẫn đúng là: http://localhost:6969/public/
	Khi tách các tập tin script và Header ra thì thứ tự bị thay đổi --> cần phải có base href để định lại đường dẫn
		đặt trong thẻ <head> ---> <base href="/">
	Keyword: html base href
	Folder pages: Để định nghĩa view của từng trang, quản lý các view chẳng hạn như qua lý các view dashboard, items
	Khi thay đổi vị trí của các tập tin view thì phần nội dung trong routes phần render() cũng phải thay đổi theo
	html format: Dùng để format code html
	Mỗi trang khác nhau thì có 1 Title khác nhau, nếu như mà thay đổi cấu trúc html của nó thì có bao nhiêu trang -> 
		phải thay đổi bấy nhiêu lần. Thay vì cứ mỗi trang mình phải lặp lại cấu trúc html của title thì mình sẽ tách nó
		ra thành 1 file riêng để khi mà khi thay đổi cấu trúc html dành cho title thì chỉ cần sửa ở 1 chỗ mà thôi
	In ra giá trị được truyền từ Router ra View: <%= pageTitle %>
	--> Tách ra thêm 1 phần quản lý title
	Keyword: ejs --> https://ejs.co/
	Nhúng giao diện cho phần add items
	Ở cứ mỗi trang thì mỗi view của nó tương đối là ít --> không cần Copy cấu trúc html của toàn bộ trang, nếu như mà 
		cấu trúc html của trang thay đổi thì mình phải đi tất cả các trang để thay đổi
		để tối ưu mã html thì ở mỗi trang, nó chỉ chứa mã html của chính nó --> mà ko cần chứa mã của toàn bộ trang
	Tùy thuộc vào việc mình sử dụng template engine là gì thì nó sẽ có package để tách được phần layouts ra
	Keyword: express-ejs-layouts --> https://www.npmjs.com/package/express-ejs-layouts
	Cài đặt: npm install express-ejs-layouts
	Khi cài đặt thành công thì kiểm tra trong file package.json và folder node_modules thì thấy nó đã có thêm 
		express-ejs-layouts
	Sau khi cài đặt xong thì import nó vào tập tin chạy chính app.js để sử dụng: 
		var expressLayouts = require('express-ejs-layouts');
	Thứ tự sắp xếp các module trong app.js:
		module của hệ thống 
		module cài thêm vào
		module tự viết
			var createError = require('http-errors');
			var express = require('express');
			var path = require('path');
			var cookieParser = require('cookie-parser');
			var logger = require('morgan');

			var expressLayouts = require('express-ejs-layouts');

			var indexRouter = require('./routes/index');
			var usersRouter = require('./routes/users');
	Khai báo sử dụng: app.use(expressLayouts);
	Set custom default layout: app.set('layout', 'layouts/layout');
	Tùy thuộc vào vị trí layout được đặt ở đâu thì tương ứng ta sẽ có đường dẫn, đường dẫn sẽ được tính từ Folder views
	In ra content: <%- body %>
	---> Trong app.js mình cài đặt express-ejs-layouts, khai báo sử dụng layout default là backend, trong backend thì 
		khai báo sử dụng cho phần content là <%- body %>

- Setup Router:
	Truy cập vào mỗi trang bằng cách gắn link
	Phần quản lý đường link thì mình có các đường link cho người quản trị và các đường link cho người sử dụng bình thường
		ở phần này mình sẽ xây dựng cho phần quản lý admin
	Theo cách viết ở trên thì trong file app.js mình cần import rất nhiều các Router vào, theo cách viết như vậy thì sẽ làm cho app.js
		có nhiều dòng. Ý tưởng ở đây là trong routes mình sẽ kéo các Router khác vào--> trong app.js mình chỉ cần kéo 
		file đại diện của từng phần(items, categories...) vào mà thôi, đồng thời giúp cho phần routes cũng rất dễ quản lý
		res.render('pages/home/index', { pageTitle: 'HomePage' }) --> Cách viết đúng
		res.render('/pages/home/index', { pageTitle: 'HomePage' }) --> Cách viết sai
	Đối với phần routes thì chia ra 2 phần là backend và frontend để dễ quản lý--> trong app.js chit cần import vào backend và
		frontend là được ---> đến khi thêm 1 view mới cho backend hoặc frontend thì chỉ cần viết trong routes/backend và
		routes/frontend rồi import và trong index của 2 thằng này là được

- Prefix Admin:
	Trong ứng dụng thì khả năng mở rộng, khả năng chuyển biến linh hoặt của nó phải cao
	Local variable: Là variable có thể sử dụng trong ứng dụng của mình
		app.locals.systemConfig = 'admin123'

- Error Page:
	Khi truy cập vào một đường dẫn không tồn tại --> phần error handler sẽ được gọi --> nó sẽ render về tập tin là error
		khi render ra trang error thì sẽ phát sinh lỗi bởi vì hiện tại app đang sử dụng layout là backend, layout này import
		vào title-page --> trong đây có sử đến pageTitle. Việc này dẫn đến khi render ra trang error thì nó chưa được truyền
		vào biến pageTitle --> lỗi bị phát sinh --> muốn không có lỗi thì khi render ra trang error thì chỉ cần truyền vào
		thêm biến pageTitle
	Có thể thay đổi cho trang Error như vị trí, nội dung hiển thị...

- Review NodeJS:
	Tìm hiểu cơ bản về nodejs
	Cơ bản về cách dùng ExpressJs
	routes: Phân ra thành folder backend dành cho Router cho phần quản trị backend
			frontend dành cho phần quản trị frontend
	views: Tách ra cho từng trang riêng
	Giảm thiểu mã nguồn trùng lặp bằng cách sử dụng layouts backend
	Ngoài việc sử dụng template engine là ejs mình cũng đã sử dụng thêm 1 module nữa đó là express-ejs-layouts

- Mlab:
	Site: https://mlab.com/
	MongoDB Atlas: https://www.mongodb.com/cloud/atlas
	Tạo được ra DB ra trong MongoDB

- MongoDB Connect: Biết cách kết nối vơi mongodb thông qua dịch vụ của mlab
	Cách kết nối với cơ sở dữ liệu sử dụng MongoDB
	Thư viện(package) phổ biến giúp ta có thể làm việc được với MongoDB đó là Mongoose
	Site: https://mongoosejs.com/
		  https://mongoosejs.com/docs/guide.html  --> Bắt đầu từ Quick Start
	Cài đặt: npm install mongoose
	Keyword: mongodb atlas connect node
		--> https://docs.atlas.mongodb.com/connect-to-cluster/
	Trước tiên thì cần thực hiện 1 số yêu cầu:
		Tạo project: Training
		Thực hiện thêm Cluster mới
			Cluster Name: Cluster0
		Whitelist: Thực hiện add IP address  ở tab Security --> Add IP Address --> Allow Access from Anywhere, 
			khi add chỉ cần thực hiện các thông số mặc định 0.0.0.0/0
		MongoDB User: Để truy cập được vào cluster thì cần phải add thêm MongoDB User để có thể truy cập vào các 
			CSDL mong muốn trên Atlas cluster. Tài khoản MongoDB User là khác với tài khoản Atlas users. MongoDB user
			là dùng để truy cập vào CSDL MongoDB, còn Atlas users là để login vào ứng dụng Atlas
			user: vuquang
			pass: Vudinhquang2202
			Phân quyền là: Read and write to any database
		Kết nối với Cluster: Connect Your Application

- MoogoDB Quickstart

- Mongoose basic:
	Thực hiện hiển thị danh sách các item -> Cần đến câu lệnh Sellect
	Để dễ quản lý -> tạo thêm thư mục schemas, mỗi Collection sẽ có 1 tập tin schema riêng: items, categories...
	Keyword: mongoose get all items
	Mongoose thực hiện các phương thức và kết quả trả về được truyền vào lmaf tham số của hàm callback, đồng thời
		Mongoose cũng có phương thức .then() để thực hiện tiếp theo bước truy vấn.
		Tất cả các hàm callback đều có dạng callback(error, result)
			Trong trường hợp có lỗi xảy ra thì tham số error sẽ trả về 1 error parameter và result là null
			Ngược lại nếu truy vấn thành công thì error trả về null và result là kết quả của câu query

- Get items: Thực hiện truy vấn dữ liệu item và truyền ra view
	Ở đây thì dữ liệu được đổ ra view /admin/items --> Trong routes của items phải thực hiện lấy ra các items trong
		DB rồi truyền ra view
	Keyword: javascript print object

- Foreach:
	Khi đổ dữ liệu items ra view sử dụng Foreach --> hiển thị dữ liệu ra phần list item
	Để hiện thị các thông báo lỗi trong trang error để kiểm tra lỗi khi code:
		<h1><%= message %></h1>
		<h2><%= error.status %></h2>
		<pre><%= error.stack %></pre> 

- Status Helper:
	Khi xây dựng thêm các phần quản lý khác như categories, video... thì trên các view nó cũng có phần Status, phần này	
		sẽ được lặp lại -> Xây dựng phần Helpers hỗ trợ cung cấp sinh ra mã HTML giúp cho việc maintain cũng dễ dàng
	Include helper đã viết: <% include ../../helpers/status %>

- Show status filter: Lọc items theo status active, inactive, all + hiện thị có bao nhiêu phần tử ở trạng thái đó
	-> Các thuộc tính của mỗi nút filter đó là: 
		name: All/Active/Inactive, count: 4, link: '#', class(khi click vào phần tử nào thì phần tử đó được active)

- Count by status:
	Đối với trường status thì có thể nó có rất nhiều trạng thái: active, unactive, public, trash... -> thiết lập giá trị
		cho trường này là các giá trị text

- Helper Show Filter Status:
	Xây dựng helper cho phần hiển thị phần Filter trên view

- Helper Create Filter Status:
	Viết helper để tạo ra phần Status Filter -> làm giảm thiểu mã nguồn trong routes
	Sử dụng phương thức countDocuments() thay cho phương thức count()

- Status router:
	Dựa vào URL có thể lấy được các giả trị status: all, active, inactive, rồi từ đó hiện thị các giá trị theo Status
		đồng thời add class Css vào cho các nút Filter theo Status
	Cách ghi tổng quát cho status
		router.get('/:status', (req, res, next) => {
			res.write('test');
			res.end();
		});
	Cách lấy giá trị của status: req.params.status
	(/:status)?  -> trên URL thì giá trị này có thể xuất hiện hoặc không

- Active filter:
	Active cho các button Filter Status khi click vào các button đó để chuyển trang
	Hiện thị status khi hiện thị list các item

- List by status:
	Dựa vào trạng thái status ở trên URL mà mình sẽ đổ danh sách item ra ở phần list

- getParam:
	Khi mà không lấy được status từ URL, hoặc là giá trị của nó bằng rỗng thì gán giá trị mặc định cho nó là all
		nếu mà nó có tồn tại thì lấy giá trị của nó bình thường
	Keyword: javascript check object has property. javascript hasOwnProperty example
	--> Xử lý đế lấy giá trị: currentStatus
	Helper get param:
		let getParam = (params, property, defaultValue) => {
			if (params.hasOwnProperty(property) && params[property] !== undefined) {
				return params[property];
			}
			return defaultValue;
		}
		
- Filter Status - Error:
	Khi nhấn vào các filter status thì ta sẽ có các đường dẫn có dạng như:
		/status/active
		/status/inactive
		--> 'status' được bổ sung vào URL
	Error: Có lỗi bất đồng bộ xảy ra khi hiện thị giá trị count của mỗi status

- Submit keyword: Thực hiện lấy giá trị keyword nhập vào khi nhấn nút Submit
	Khi nhắn nút tìm kiếm thì giá trị keyword được gắn lên trên URL, sau đó lấy giá trị keyword trên URL xuống để tìm
		kiếm
	Tùy thuộc vào mình đang ở trạng thái nào mà ta có đường link tương ứng khi tìm kiếm: /items/all?keyword=abc
		--> Truyền giá trị status hiện tại ra view để gắn vào đường link
	Khi nhấn vào nút Search để tìm theo keyword thì giá trị keyword nhập vào vẫn phải được hiển thị trên ô input
		-> Trong routes mình cần lấy được keyword trên URL rồi truyền nó ra view
	app.use(logger('dev')) ---> comment để ẩn đi một số dòng hiển thị trong console

- Search normarl: Đưa ra trị keyword lấy được ra view -> đưa vào hiển thị trong ô input, và lọc các item theo keyword đó
	hiển thị ở phần view

- Search RE: Tìm kiếm sử dụng đến Regular Expression
	keyword: mongoose Regular Expression, mongoose find regex
	objWhere = {name: { $regex: /socket/, $options: 'i' }}
		Tìm các giá trị có chứa giá trị 'socket' và không phân biệt chữ hoa, chữ thường
	objWhere = {name: new RegExp(keyword, 'i')};

- Clear & Reset: 
	Clear: Nhấn vào nút Clear để thực hiện xóa việc tìm kiếm -> quay về trạng thái ban đầu không thực tìm kiếm theo
	keyword
		Cách 1: Khi nhấn vào nút Clear thì thực hiện xóa giá trị trong ô input và thực hiện Submit Form
		Cách 2: Gắn link vào cho nút Clear, khi mà nhấn nút Clear thì quay về trang với status hiện tại
	Refresh: Vừa Reset phần Search -> không tìm kiếm theo status, vừa Reset theo status -> status được Reset về giá trị
		default là All
		-> Cách làm giống như là nút Clear, nhưng ở đây ta có status là All

- Update Filter status link:
	Khi thực hiện tìm kiếm theo keyword, người dùng nhấn vào nút chuyển trạng thái -> giá trị keyword vẫn phải được giữ
		nguyên trong ô input

---------------------------------------------------------------------------------------------

							Xây Dựng Chức Năng Phân Trang	

- Sort Helper:	Khi lấy dữ liệu ra thì mình cần có sự sắp xếp
	<%- %>: In ra mã HTML
	<%= %>: In ra giá trị của 1 biến 
	--> Khi return về mã HTML mà mình muốn in nó ra thì dùng <%- %>
	keyword: mongoose sort by date -> sort()
	Ở mỗi phần(item, user, group, category...) nếu chúng đều có phần phân trang -> Xây dựng Helper cho phần phân trang

- Fix Helper Status:
	`` ----> ${link}
	Sửa Helper cho phần status
	Sửa Helper cho phần filterStatus

- List by page:
	Cần xác định được có bao nhiêu phần tử trên một trang(limit)	-> Cấu hình
	Cần biết đang ở trang nào để biết là lấy từ phần tử nào(skip) --> Lấy trên URL
	keyword: javascript convert string to int
	skip:(currentPage -1)*totalItemsPerPage

- Total Items:
	Thống kê tổng cộng có bao nhiêu phần tử
	Tổng cộng có bao nhiêu trang
	Khi tìm kiếm cũng phải lọc theo Status và keyword

- Number:
	Thống kê tổng số trang: totalItems/totalItemsPerPage
	Tổng số phần tử trên một trang
	Ở trang hiện tại hiển thị phần tử nào đến phần tử nào: from -> to
		Nếu mà to > totalItems thì gán to = totalItems

- Start, Previous:
	Nút Start: Có thể có link hoặc không
		Nếu không phải trang đầu tiên -> có link
		Nếu là trang đầu tiên thì nó có link(disable)
	Nút Previous: 
		Khi đang ở trang 1 thì không cần có link
		Khi ở từ trang 2 trở đi thì cần có link

- Next, End: Xây dựng cũng tương tự như 2 nút Start và Previous
	Nếu trang hiện tại không phải trang cuối cùng thì gắn link cho Next và End
	Nếu mà đang ở trang đầu tiên thì không cần hiển thị 2 nút Start và Previous
	Nếu đang ở trang cuối cùng thì không cần hiển thị 2 trang Next và End
	--> Ban đầu gắn cho nó các giá trị là rỗng
	keyword: javascript declare multi variable --> Định nghĩa nhiều variable trên cùng 1 dòng

- Pages: Xây dựng phần giao diện để hiện thị những con số ở phần phân trang
	Cần có thêm phần active, chẳng hạn như nếu đang ỏ trang 3 thì ở 3 không cần gắn link cho nó và gắn thêm cho nó
		thêm 1 class(active)
	Tham khảo thêm cấu tạo của phần phân trang của Bootstrap 3

- Pagerange: Giới hạn số trang hiển thị ở phần hiển thị các con số
	-> Thiết lập thêm là muốn hiện thị lên bao nhiêu trang, thay vì có bao nhiêu trang thì hiện thị lên hết bấy 
		nhiêu trang
	VD: totalItems = 15, totalItemsPerPage = 2 -> totalPage = 8, pageRange = 5 -> midle = 5/2 = 3
		currentPage		xhtmlPages								 min = currentPage - midle + 1     max	= min + pageRange -1
		1				1 2 3 4 5									  1 - 3 + 1 = -1 <= 1 -> 1	   5				
		2				1 2 3 4 5									  2 - 3 + 1	= 0	 <= 1 -> 1	   5
		3				1 2 3 4 5									  3 - 3 + 1	= 1	 <= 1 -> 1     5

		4				2 3 4 5 6 -> currentPage nằm ở giữa		--	  4 - 3 + 1	= 2  			   6	 = 2 + 5 -1
		5				3 4 5 6 7 -> currentPage nằm ở giữa		--	  5 - 3 + 1	= 3				   7	 = 3 + 5 -1

		6				4 5 6 7 8									  6 - 3 + 1	= 4   -> 4		   8	   4 + 5 -1	= totalPage -> totalPage
		7				4 5 6 7 8									  7 - 3 + 1	= 5	  -> 4		   8	   5 + 5 -1 > totalPage -> totalPage
		8				4 5 6 7 8									  8 - 3 + 1	= 6   -> 4		   8	   6 + 5 -1 > totalPage -> totalPage
		--> Giá trị đầu và cuối sẽ thay đổi tùy thuộc vào giá trị của currentPage
			Do đó mình sẽ đặt ra 2 giá trị là min và max(của dãy số nằm trong pageRange)
			-> Cần xác định 2 giá trị min và max

- Fix pagination: Hoàn thiện cho phần phân trang
	Giải quyết trường hợp khi totalPages nhỏ hơn hoặc bằng giá trị thiết lập pageRanges -> min sẽ có giá trị là 1
	Khi nếu chỉ có 1 trang thôi thì không cần hiển thị cũng được --> xhtmlPagination = ''

- Link pagination:
	Giữ lại trạng thái lọc theo Status, cũng như giá trị tìm kiếm khi chuyển sang trang khác -> truyền giá trị Status
		ra helper pagination	
	Có cách sử lý khác đó là đưa các giá trị Status và keyword vào trong Session
	Phần quản lý pagination sẽ là phần dùng chung cho nhiều các phần quản lý khác: items, user, category -> để tổng quát
		hơn thì ở phần tạo link của pagination cần thêm 1 variable là type(items, user, category) -> dễ dàng tái sử dụng 
		mã nguồn	

- Link change status: Thay đổi trạng thái của 1 phần tử nào đó
	admin/items/change-status/12/active -> lấy được id và status của phần tử hiện tại
	res.send('test'): Truyền ra browser giá trị là 'test'

----------------------------------------------------------------------------------------------------

- Change status:
	Từ giá trị id và Status tiến hành cập nhật lại status cho item
	active <-> inactive
	keyword: Mongoose updateOne
	then()
	res.redirect() ---------res: Response
	Chỉnh sửa cho phần Change status bằng cách khi redirect về trang items thì ko fix cứng giá trị admin trong đường dẫn
		mà sử dụng giá trị trong config

- Delete item: Thực hiện chức năng là xóa 1 phần tử nào đó
	deleteOne()
	const linkIndex: Khai báo biến link cho index để có thể dùng chung cho các route

- Xây dựng chức năng Change Status cho nhiều phần tử:
	Chọn những phần tử mà mình muốn thay đổi trạng thái cho nó
	Chọn trạng thái muốn thay đổi
	Nhấn Apply
	Khi vừa vào trang thì nút Apply không Click được(vì chưa chọn hành động)
	Nếu nhấn nút Apply khi chưa chọn phần tử nào thì sẽ hiện lên câu thông báo yêu cầu chọn phần tử để thay đổi
	change_form_action: Chứa 3 tham số
		Tham số thứ nhất: Sellect box. Trong các option của Sellect Box thì lưu trực tiếp link mình muốn Submit đến
		Tham số thứ 2: Form -> chứa cả các input là checkbox, để khi mà Form Submit đi Form sẽ nhận được các giá trị 
			checkbox đó -> biết phần tử muốn thay đổi là phần tử nào
		Tham số thứ 3: Nút Apply
	test() trong javascript: Kiểm tra 1 giá trị nào đó có nằm trong 1 chuỗi hay không
	Form để method là post
	console.log(req.body): Kiểm tra các giá trị có trong req -> giúp ta lấy được các dữ liệu gửi từ Form
	keyword: mongoose update many, mongo update many
	https://docs.mongodb.com/manual/reference/operator/query/#query-selectors

- Delete multi item:
	Khi nhấn Apply để Delete thì hộp thoại để xác nhận được hiện lên
	Cần lấy được danh sách các id của item mà người dùng muốn xóa
	remove()

- Change ordering: Xây dựng chức năng Change Ordering của nhiều phần tử:
	Nhập giá trị mới cho ordering
	checkbox
	Chọn Change Ordering và nhấn nút Apply
	-> Có id và các giá trị ordering của các item muốn thay đổi
	Phần tử được check: $(".ordering").attr("name", "ordering")
	Phần tử không được check: $(".ordering").removeAttr("name")
	Có 2 trường hợp cập nhật đó là: Cập nhật 1 item và cập nhật nhiều item
	keyword: mongoose updateMany() -> giá trị update là cố định
	Cấu trúc từ phần Select, Button Apply và Button Add New khi mà qua các phần quản lý khác như quản lý User, quản
		lý group... sẽ tiếp tục lặp lại cấu trúc html đó -> tạo mới helper
	filterStatusHelper(): Thêm 1 tham số mới đó là collection rồi truyền vào giá trị là items
	actionHelper(): Để tạo mã html cho phần thay đổi status, ordering, delete